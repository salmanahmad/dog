#
# Copyright 2011 by Salman Ahmad (salman@salmanahmad.com).
# All rights reserved.
#
# Permission is granted for use, copying, modification, distribution,
# and distribution of modified versions of this work as long as the
# above copyright notice is included.
#

module Dog

grammar Dog

  # ================
  # = Core Program =
  # ================
  
  rule program
    statements <::Dog::Nodes::Program> 
    / 
    '' <::Dog::Nodes::Program>
  end
  
	# TODO: I removed program statements because I don't need them anymore...

  #rule program_statements
  #  (top_level_statement / statement / s) t <::Dog::Nodes::ProgramStatements>
  #  / 
  #  "\n" / comment
  #end
  
	# TODO - what about ;;;;;;

  rule statements
    ((statement / s t) / ("\n" / comment))+ <::Dog::Nodes::Statements>
  end
  
	# TODO: I removed import, config, reply_disallow as top_level_statements. They are
	# just normal statements now, but I can restrict their  useage in the postprocess/codegen
	# compilation phase. 

  #rule top_level_statement
  #  (import / config / reply_disallow) s? <::Dog::Nodes::TopLevelStatement>
  #end
	
	rule statement
		s? (assignment / expression) s?
	end
	
	rule assignment 
		access s? assignment_operator s? expression
	end
	
	rule expression
		literal / access / operation / command / '(' s? expression s?')'
	end
	
  rule statement 
    s? (command / expression) s? <::Dog::Nodes::Statement>
  end
  
  rule expression
    assignment / primary
  end
  
  rule command
     listen / allow / notify / on / ask / compute / people / control_structure / function / reply / print / inspect / import / config
  end
  
  # ===============
  # = Expressions =
  # ===============
  
  rule assignment
    lhs s? assignment_operator s? (ask / notify / compute / people / person) <::Dog::Nodes::Assignment>
    / 
    lhs s? assignment_operator s? primary <::Dog::Nodes::Assignment>
  end
  
  rule primary
    operation / access / literal / identifier / '(' s? primary s? ')' <::Dog::Nodes::Primary>
  end
  
  rule operation
    operation_first s? binary_operator s? (operation / operation_first) <::Dog::Nodes::Operation>
    / 
    unary_operator s primary <::Dog::Nodes::Operation>
  end
  
  rule operation_first
    literal / access / identifier / '(' s? primary s? ')' <::Dog::Nodes::Primary>
  end
  
  rule access
    access_first access_tail <::Dog::Nodes::Access>
  end
  
  rule access_first
    literal / identifier / '(' s? primary s? ')' / '(' s? operation s? ')'
  end
  
  rule access_tail
    access_dot / access_bracket / access_possessive
  end
  
  rule access_dot
    '.' identifier access_tail? <::Dog::Nodes::AccessDot>
  end
  
  rule access_bracket
    s? '[' s? primary s? ']' s? access_tail? <::Dog::Nodes::AccessBracket>
  end
  
  rule access_possessive
    ('\'s' / '\'') s identifier access_tail? <::Dog::Nodes::AccessPossessive>
  end
  
  rule lhs
    (access / identifier)
  end
  
  rule identifier
    lower (lower / digit / '_')* <::Dog::Nodes::Identifier>
  end

  rule binary_operator
    arithmetic_operator / collection_operator / comparative_operator / and_operator / or_operator
  end
  
  rule unary_operator
    not_operator
  end
  
  rule assignment_operator
    '=' <::Dog::Nodes::AssignmentOperator>
  end
  
  rule arithmetic_operator
    addition_operator / subtraction_operator / multiplication_operator / division_operator
  end
  
  rule comparative_operator
    equality_operator / inequality_operator / greater_than_operator / less_than_operator / greater_than_equal_operator / less_than_equal_operator / associates_operator / contains_operator
  end
  
  rule logical_operator
    and_operator / or_operator / not_operator
  end
  
  rule collection_operator
    union_operator / intersect_operator / difference_operator / append_operator / prepend_operator
  end
  
  rule addition_operator
    '+' <::Dog::Nodes::AdditionOperator>
  end
  
  rule subtraction_operator
    '-' <::Dog::Nodes::SubtractionOperator>
  end
  
  rule multiplication_operator
    '*' <::Dog::Nodes::MultiplicationOperator>
  end
  
  rule division_operator
    '/' <::Dog::Nodes::DivisionOperator>
  end
  
  rule equality_operator
    '==' <::Dog::Nodes::EqualityOperator>
  end
  
  rule inequality_operator
    '!=' <::Dog::Nodes::InequalityOperator>
  end
  
  rule greater_than_operator
    '>' <::Dog::Nodes::GreaterThanOperator>
  end
  
  rule less_than_operator
    '<' <::Dog::Nodes::LessThanOperator>
  end
  
  rule greater_than_equal_operator
    '>=' <::Dog::Nodes::GreaterThanEqualOperator>
  end
  
  rule less_than_equal_operator
    '<=' <::Dog::Nodes::LessThanEqualOperator>
  end
  
  rule and_operator
    'AND' <::Dog::Nodes::AndOperator>
  end
  
  rule or_operator
    'OR' <::Dog::Nodes::OrOperator>
  end
  
  rule not_operator
    'NOT' <::Dog::Nodes::NotOperator>
  end
  
  rule union_operator
    'UNION' <::Dog::Nodes::UnionOperator>
  end
  
  rule intersect_operator
    'INTERSECT' <::Dog::Nodes::IntersectOperator>
  end
  
  rule difference_operator
    ('DIFFERENCE' / 'DIFF' / 'MINUS') <::Dog::Nodes::DifferenceOperator>
  end
  
  rule append_operator
    'APPEND' <::Dog::Nodes::AppendOperator>
  end
  
  rule prepend_operator
    'PREPEND' <::Dog::Nodes::PrependOperator>
  end
  
  rule associates_operator
    "ASSOCIATES" <::Dog::Nodes::AssociatesOperator>
  end
  
  rule contains_operator
    "CONTAINS" <::Dog::Nodes::ContainsOperator>
  end
  
  # ==============
  # = Structures =
  # ==============
  
  rule structure_definition
    identifier s identifier s '{' sn? structure_properties? sn? '}' <::Dog::Nodes::StructureDefinition>
  end
  
  # TODO - It is so stupid that I have to do this. Figure out a better way to get PEGs to work
  # or figure out a bettery way to "clean_tree" in the parser. This is kind of annoying...
  rule structure_nested_definition
    structure_definition sn <::Dog::Nodes::StructureNestedDefinition>
  end
  
  rule structure_properties
    (structure_nested_definition / structure_relationship_property / structure_property)+ <::Dog::Nodes::StructureProperties>
  end
  
  rule structure_relationship_property
    'relationship' s structure_property_name s? structure_relationship_property_inverse? sn <::Dog::Nodes::StructurePropertyRelationship>
  end
  
  rule structure_relationship_property_inverse
    ',' s?  (structure_relationship_property_inverse_identifier_path / identifier) <::Dog::Nodes::StructurePropertyRelationshipInverse>
  end
  
  rule structure_relationship_property_inverse_identifier_path
    identifier '.' identifier <::Dog::Nodes::StructurePropertyRelationshipPath>
  end
  
  rule structure_property
    s? event_property_direction? (structure_property_type / structure_property_name) (s '=' s primary)? sn <::Dog::Nodes::StructureProperty>
  end
  
  rule structure_property_type
    identifier s identifier <::Dog::Nodes::StructurePropertyType>
  end
  
  rule structure_property_name
    identifier '' <::Dog::Nodes::StructurePropertyName>
  end
  
  rule event_property_direction
    (event_property_direction_input / event_property_direction_output) s <::Dog::Nodes::StructurePropertyDirection>
  end
  
  rule event_property_direction_input
    'input' <::Dog::Nodes::StructurePropertyDirectionInput>
  end
  
  rule event_property_direction_output
    'output' <::Dog::Nodes::StructurePropertyDirectionOutput>
  end
  
  rule structure 
    identifier s '{' sn? structure_properties? sn? '}' <::Dog::Nodes::Structure>
  end
  
  
  
  # ==================
  # = Listen Command = 
  # ==================

  rule listen
    'LISTEN' listen_to_clause via_clause listen_at_clause? listen_for_clause <::Dog::Nodes::Listen>
  end

  rule listen_to_clause
    s 'TO' s (user / identifier) <::Dog::Nodes::ListenToClause>
  end

  rule listen_for_clause
    s 'FOR' s identifier <::Dog::Nodes::ListenForClause>
  end

  rule listen_at_clause
    s 'AT' s string <::Dog::Nodes::ListenAtClause>
  end
  
  
  
  # =========
  # = Allow =
  # =========
  
  rule allow
    'ALLOW' s (user / identifier) s 'TO' s allow_modifier s (allow_profile / identifier)
  end
  
  rule allow_modifier
    'JOIN' <::Dog::Nodes::AllowModifier>
    / 
    'READ' <::Dog::Nodes::AllowModifier>
    / 
    'WRITE' <::Dog::Nodes::AllowModifier>
    /
    'ACCESS' <::Dog::Nodes::AllowModifier>
  end
  
  rule allow_profile
    'PROFILE' <::Dog::Nodes::AllowProfile>
  end
  
  # ===============
  # = Ask Command =
  # ===============

  rule ask
    'ASK' sn (integer sn)? (user / identifier) via_clause ask_to_clause on_clause? using_clause? <::Dog::Nodes::Ask>
  end

  rule ask_to_clause
    s 'TO' s (identifier / string) <::Dog::Nodes::AskToClause>
  end

  # ==========
  # = Notify =
  # ==========

  rule notify
    'NOTIFY' s (user / identifier) via_clause notify_of_clause using_clause? <::Dog::Nodes::Notify>
  end

  rule notify_of_clause
    s 'OF' s (access / identifier / string) <::Dog::Nodes::NotifyOfClause>
  end

  
  # =========
  # = Reply =
  # =========

  rule reply
    'REPLY' s 'TO' s (user / identifier) reply_with_clause <::Dog::Nodes::Reply>
  end
  
  rule reply_with_clause
    s 'WITH' s identifier_associations <::Dog::Nodes::ReplyWithClause>
  end
  
  rule reply_disallow
    reply '' <::Dog::Nodes::ReplyDisallow>
  end


  # ===================
  # = Compute Command =
  # ===================

  rule compute
    'COMPUTE' s identifier on_clause? using_clause? <::Dog::Nodes::Compute>
  end


  # ==================
  # = People Command =
  # ==================

  rule user
    me / public / people / person
  end

  rule me
    'ME' <::Dog::Nodes::Me>
  end

  rule public
    'PUBLIC' <::Dog::Nodes::Public>
  end
  
  rule person
    'PERSON' people_from_clause? (people_where_clause)? <::Dog::Nodes::Person>
  end
  
  rule people
    'PEOPLE' people_from_clause? (people_where_clause)? <::Dog::Nodes::People>
  end
  
  # TODO - fix the AST for PERSON FROM variable
  # TODO - Add back community list. Right now, you can only access people from 
  # one community at a time...
  rule people_from_clause
    sn 'FROM' sn (access / identifier) <::Dog::Nodes::PeopleFromClause>
  end

  rule people_where_clause
    sn 'WHERE' sn predicate <::Dog::Nodes::PeopleWhereClause>
  end
  
  rule predicate
    predicate_unary / predicate_binary / predicate_primary
  end 
  
  rule predicate_unary
    not_operator s? '(' s? predicate_primary s? ')' <::Dog::Nodes::PredicateUnary>
  end
  
  rule predicate_binary
    predicate_primary s (and_operator / or_operator) s predicate <::Dog::Nodes::PredicateBinary>
  end
  
  rule predicate_primary 
    predicate_parenthesis / predicate_conditional
  end 
  
  rule predicate_parenthesis 
    '(' s? predicate s? ')' <::Dog::Nodes::Predicate>
  end
  
  # TODO consider supporting primaries here. The problem is that it will
  # get confused with the "AND" and "OR" from a primary. There may be a
  # a way to reuse them between the two, but I am not sure...
  rule predicate_conditional
    key_paths s? comparative_operator s? (literal / access / identifier) <::Dog::Nodes::PredicateConditonal>
  end
  
  rule key_paths
    key_path+ <::Dog::Nodes::KeyPaths>
  end
  
  rule key_path
    identifier ('.' &key_path / '' !key_path) <::Dog::Nodes::KeyPath>
  end
  

  # ==============
  # = On Command =
  # ==============
  
  rule on
    'ON' (s 'EACH' (s integer)?)? in_clause 'DO' sn statements? s? 'END' <::Dog::Nodes::On>
  end
  
  
  
  # ===================
  # = Others Commands =
  # ===================
  
  # TODO - Support for primaries instead of literals
  rule config
    'CONFIG' s identifier s '=' s literal <::Dog::Nodes::Config>
  end
  
  rule function
    'DEFINE' s identifier function_on? function_using? s? 'DO' sn statements? 'END' <::Dog::Nodes::Function>
  end
  
  rule function_on
    s 'ON' s function_parameters <::Dog::Nodes::FunctionOn>
  end
  
  rule function_parameters
    function_parameter+ <::Dog::Nodes::FunctionParameters>
  end
  
  rule function_parameter
    s? identifier ((s? ',' &function_parameter) / ('' !function_parameter)) <::Dog::Nodes::FunctionParameter>
  end
  
  rule function_using
    s 'USING' s function_optional_parameters <::Dog::Nodes::FunctionUsing>
  end
  
  rule function_optional_parameters
    function_optional_parameter+ <::Dog::Nodes::FunctionOptionalParameters>
  end
  
  rule function_optional_parameter
    s? identifier s? '=' s? literal s? (',' &function_optional_parameter / '' !function_optional_parameter) <::Dog::Nodes::FunctionOptionalParameter>
  end
  
  rule import 
    'IMPORT' s (import_function / import_data / import_community / import_task / import_message / import_config) s string import_as? <::Dog::Nodes::Import>
  end
  
  rule import_as
    s 'AS' s identifier <::Dog::Nodes::ImportAsClause>
  end
  
  rule import_function
    'FUNCTION' <::Dog::Nodes::ImportFunction>
  end
  
  rule import_data
    'DATA' <::Dog::Nodes::ImportData>
  end
  
  rule import_community
    'COMMUNITY' <::Dog::Nodes::ImportCommunity>
  end
  
  rule import_task
    'TASK' <::Dog::Nodes::ImportTask>
  end
  
  rule import_message
    'MESSAGE' <::Dog::Nodes::ImportMessage>
  end
  
  rule import_config
    'CONFIG' <::Dog::Nodes::ImportConfig>
  end
  
  rule print
    'PRINT' space primary <::Dog::Nodes::Print>
  end
  
  rule inspect
    'INSPECT' space primary <::Dog::Nodes::Inspect>
  end


  # ==================
  # = Shared Clauses =
  # ==================

  rule using_clause
    s 'USING' s identifier_associations <::Dog::Nodes::UsingClause>
  end
  
  rule on_clause 
    s ('ON' s)? on_clause_items <::Dog::Nodes::OnClause>
  end

  rule via_clause 
    s 'VIA' s identifier <::Dog::Nodes::ViaClause>
  end
  
  # TODO - Allow IN to process on primaries
  rule in_clause
    s in_clause_identifiers s <::Dog::Nodes::InClause>
  end
  
  rule in_clause_identifiers
    (
      identifier s 'IN' s key_paths <::Dog::Nodes::InClauseIdentifiers>
      /
      key_paths '' <::Dog::Nodes::InClauseIdentifiers>
    )
  end
  




  # =========
  # = Lists =
  # =========

  rule on_clause_items
    on_clause_item+ <::Dog::Nodes::OnClauseItems>
  end

  rule on_clause_item
    s? primary ((s? ',' &on_clause_item) / ('' !on_clause_item)) <::Dog::Nodes::OnClauseItem>
  end
  
  rule identifier_associations
    identifier_association+ <::Dog::Nodes::IdentifierAssociations>
  end

  rule identifier_association
    identifier_association_explicit / identifier_association_implicit
  end

  rule identifier_association_explicit
    sn? identifier s? '=' s? primary s? (',' &identifier_association / '' !identifier_association) <::Dog::Nodes::IdentifierAssociation>
  end
  
  rule identifier_association_implicit
    s? identifier s? (',' &identifier_association / '' !identifier_association)
  end


  # ======================
  # = Control Structures =
  # ======================

  rule control_structure
    if / for / repeat / break
  end

  rule repeat
    'REPEAT' s integer s 'DO' sn statements? s? 'END' <::Dog::Nodes::Repeat>
  end

  rule if
    'IF' s primary s 'THEN' sn statements? else_clause? s? 'END' <::Dog::Nodes::If>
  end
  
  rule else_clause
    sn? 'ELSE' sn statements? <::Dog::Nodes::ElseClause>
  end

  rule for
    'FOR' s 'EACH' in_clause 'DO' sn statements? s? ('END' / ('UNTIL' s primary)) <::Dog::Nodes::For>
  end
  
  rule break
    'BREAK' <::Dog::Nodes::Break>
  end
  


  # ================
  # = Dog literals =
  # ================

  rule literal
    number / string / bool / collection
  end

  rule collection
    array / structure / hash
  end

  rule array 
    '[' sn? items? sn? (',' sn?)? ']' <::Dog::Nodes::ArrayLiteral>
  end

  rule items
    item+ <::Dog::Nodes::ArrayItems>
  end

  rule item
    sn? primary ((sn? ',' &item) / ('' !item)) <::Dog::Nodes::ArrayItem>
  end

  rule hash 
    '{' sn? associations? (sn? ',' sn?)? '}' <::Dog::Nodes::HashLiteral>
  end

  rule associations
    association+ <::Dog::Nodes::HashAssociations>
  end

  rule association 
    sn? string s? ':' s? primary sn? (',' &association / '' !association) <::Dog::Nodes::HashAssociation>
  end

  rule bool
    (true / false)
  end

  rule true
    (
      'TRUE' <::Dog::Nodes::TrueLiteral>
      / 
      'true' <::Dog::Nodes::TrueLiteral>
      /
      'YES' <::Dog::Nodes::TrueLiteral>
      /
      'yes' <::Dog::Nodes::TrueLiteral>
    ) 
  end

  rule false
    (
      'FALSE' <::Dog::Nodes::FalseLiteral>
      / 
      'false' <::Dog::Nodes::FalseLiteral>
      / 
      'NO' <::Dog::Nodes::FalseLiteral>
      / 
      'no' <::Dog::Nodes::FalseLiteral>
    ) 
  end

  rule number
    float / integer
  end

  rule integer 
    ('-' s?)? digit+ <::Dog::Nodes::IntegerLiteral>
  end

  rule float
    ('-' s?)? digit+ '.' digit* <::Dog::Nodes::FloatLiteral>
  end

  rule string
    (
    '"' ('\"' / !'"' .)* '"' <::Dog::Nodes::StringLiteral>
    /
    '\'' ('\\\'' / !'\'' .)* '\'' <::Dog::Nodes::StringLiteral>
    )
  end

  rule digit
    [0-9]
  end

  rule character
    lower / upper / '_'
  end

  rule lower
    [a-z]
  end

  rule upper
    [A-Z]
  end

  rule t
    terminal
  end

  rule terminal
    (";" / comment / "\n" / end_of_file)
  end

  rule comment
    '#' (!"\n" .)* ("\n" / end_of_file)
  end

  rule sn
    space_newline
  end

  rule space_newline
    (" " / "\t" / "\n" / "\r" / comment)+
  end

  rule s
    space
  end

  rule space
    (" " / "\t")+
  end

  rule end_of_file
    !.
  end

end

end
