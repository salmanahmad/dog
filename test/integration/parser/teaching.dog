#!/usr/bin/env dog

learners = community {}

record learner {
  string objective
  list learnables
  list teachables
  relationship friends
  relationship pairs
}

task provide_three_interests {
  instructions = "Please provide three things that you are interested in learning and teaching."
  output required string objective
  output required list learnables
  output required list teachables
}

message match {
  body = "We found a possible match for you!"
  input person possible_match
  input list learnables
  input list teachables
}



# New syntax. Basically tells dog to create a "landing page" for people to join the community
# Alternative syntax could be ACCEPT PEOPLE INTO learners

ALLOW PEOPLE TO JOIN learners



# Can also be a PEOPLE predicate instead of learner for general access control
# Can also be a variable instead of pairs for non-profile information
# Can also be a PROFILE instead of pairs to give full access to the profile
# Can also be READ, WRITE, ACCESS

ALLOW learner TO READ pairs



# We define the protocol buffer of incoming meeting requests and then coordinate

event meeting {
  input person requested_person
}

LISTEN TO PEOPLE VIA http FOR meetings


ON meeting DO
  requester = PERSON FROM meeting
  requestee = meeting.requested_person
  group = [requestee, requester]
  
  NOTIFY group VIA email OF "Hey! You guys should get together!"
END




# We are now waiting on the dormouse.account.create event (which we normally can ignore).
# However, in this case we want to customize the account create experience.

ON request IN dormouse.account.create DO
  # Get our newly created user
  user = PERSON FROM request
  
  # I know we decided not to allow you to "mixin" or "extend" instance of records
  # but I really don't know how else to do this. I think it is pretty safe and not
  # too confusing. 
  
  # Also, I really do not like our function syntax...
  COMPUTE extend ON user, learner
  
  # We ask users the provide_three_interests tasks. Notice how the output
  # is annotated in the task definitions. This is a nice improvement over
  # protocol buffers.
  interests = ASK user VIA stream TO provide_three_interests
  
  # This is a black box container that assigns keys from one hash to another
  # Once again, I note that I do not love our function sytnax...
  COMPUTE assign ON user.learner USING attributes = intrests
  
  # This is a pretty brittle matching algorithm. We likely will want to do something more principled to match
  # people up in the future. I don't know how that would look though...
  potential_matches = PEOPLE FROM learners WHERE learnables == interests.teachables OR teachables == interests.learables
  
  # Iterate over each math and notify both parties
  FOR EACH potential_match IN potential_matches DO
    
    COMPUTE append ON user.pairs, potential_match
    COMPUTE append ON potential_matche.pairs, user
    
    NOTIFY user VIA email OF match USING possible_match = match, learnables = match.learnables, teachables = match.teachables
    
    NOTIFY PERSON FROM potential_match VIA email OF match USING possible_match = user, learnables = user.learnables, teachables = user.teachables
  END
  
END



ON request IN dormouse.profile.edit DO
  user = PERSON FROM request
  
  potential_matches = PEOPLE FROM learners WHERE learnables == interests.teachables OR teachables == interests.learables
  
  FOR EACH potential_match IN potential_matches DO
    
    COMPUTE append ON user.pairs, potential_match
    COMPUTE append ON potential_matche.pairs, user
    
    NOTIFY user VIA email OF match USING possible_match = match, learnables = match.learnables, teachables = match.teachables
    
    NOTIFY PERSON FROM potential_match VIA email OF match USING 
      possible_match = user, 
      learnables = user.learnables, 
      teachables = user.teachables
  END
  
END


