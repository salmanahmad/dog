#
# Copyright 2011 by Salman Ahmad (salman@salmanahmad.com).
# All rights reserved.
#
# Permission is granted for use, copying, modification, distribution,
# and distribution of modified versions of this work as long as the
# above copyright notice is included.
#

module Dog

grammar Dog

  # ================
  # = Core Program =
  # ================

  rule program
    statements
    / 
    ''
  end
  
  rule statements
    statement+
  end
  
  # TODO - Perhaps add assignments to expressions. In ruby you can 
  # technically do stuff like this: j = (i = 5) and j = i = 5
  # Also, by combining them, we can add inline conditionals like:
  # i = 5 if true and i = 5 unless true. Right now, we can only attach
  # inline conditionals to statements, not expressions which means we can
  # only have one per "line"
  
  rule statement
    s? (expression) s? t
    /
    s t
    / 
    "\n"
    /
    ";"
    /
    comment
  end
  
  
  
  # ===============
  # = Expressions =
  # ===============
  
  rule expression
    assignment_expression
  end
  
  rule expression_no_assignment
	or_expression
  end
  
  rule assignment_expression
    assignment
    /
    or_expression
  end
  
  rule or_expression
    and_expression s or_operator s or_expression
    /
    and_expression
  end
  
  rule and_expression
    relational_expression s and_operator s and_expression
    /
    relational_expression
  end
  
  rule relational_expression
    additive_expression s? relational_operator s? relational_expression
    /
    additive_expression
  end
  
  rule additive_expression
    multiplicative_expression s? additive_operator s? additive_expression
    /
    multiplicative_expression
  end
  
  rule multiplicative_expression
    unary_expression s? multiplicative_operator s? multiplicative_expression
    /
    unary_expression
  end
  
  rule unary_expression
    unary_operator s unary_expression
    /
    primary_expression
  end
  
  rule primary_expression
    literal
    /
    access
    /
    compute
    /
    ask
    /
    listen
    /
    notify
    /
    structure_instantiation
    /
    function_definition
    /
    structure_definition
    /
    collection_definition
    /
    control_structure
    /
    import
    /
    print
    /
    inspect
    /
    on
    /
    user
    /
    '(' sn? expression sn? ')'
  end
  
  # TODO - Remove this. I am keeping it around for documentaiton purposes
  # Mostly I am keep it around so that I can remember:
  #    on
  #    import
  #    user
  #
  #rule command
  #   community / event / task / message / listen / allow / ask / notify / reply / compute / on / user / definition / control_structure / config / import / print / inspect
  #end
  
  
  # ==============
  # = Assignment =
  # ==============
  
  rule assignment
    assignment_access s? assignment_operator s? expression
  end
  
  rule assignment_access
    identifier access_tail?
  end
  
  rule access
    access_head access_tail?
  end
  
  rule access_head
    literal
    / 
    variable
    / 
    '(' s? expression s? ')'
  end
  
  rule variable 
    identifier
  end
  
  rule access_tail
    access_dot
    / 
    access_bracket
  end
  
  rule access_dot
    '.' identifier access_tail?
  end
  
  rule access_bracket
    '[' s? expression s? ']' access_tail?
  end
  
  
  
  # =============
  # = Operators =
  # =============
  
  rule assignment_operator
    '='
  end
  
  rule relational_operator
    equality_operator
    / 
    inequality_operator
    / 
    greater_than_equal_operator
    / 
    less_than_equal_operator
    / 
    greater_than_operator
    / 
    less_than_operator
  end
  
  rule additive_operator
    addition_operator 
    / 
    subtraction_operator
  end
  
  rule multiplicative_operator
    multiplication_operator 
    / 
    division_operator
  end
  
  rule unary_operator
    not_operator
  end
  
  rule addition_operator
    '+'
  end
  
  rule subtraction_operator
    '-'
  end
  
  rule multiplication_operator
    '*'
  end
  
  rule division_operator
    '/'
  end
  
  rule equality_operator
    '=='
  end
  
  rule inequality_operator
    '!='
  end
  
  rule greater_than_operator
    '>'
  end
  
  rule less_than_operator
    '<'
  end
  
  rule greater_than_equal_operator
    '>='
  end
  
  rule less_than_equal_operator
    '<='
  end
  
  rule and_operator
    'AND'
  end
  
  rule or_operator
    'OR'
  end
  
  rule not_operator
    'NOT'
  end
  
  
  
  # ===================
  # = Compute Command =
  # ===================
  
  rule compute
    'COMPUTE' s identifier on_clause? using_clause?
  end
  
  
  
  # ===============
  # = Ask Command =
  # ===============
  
  rule ask
    'ASK' sn ask_count? (user / access) via_clause ask_to_clause on_clause? using_clause?
  end
  
  rule ask_count
    integer sn
  end
  
  rule ask_to_clause
    # TODO - Bring this back
    #s 'TO' s (string / access)
    s 'TO' s identifier
  end
  
  
  
  # ==================
  # = Listen Command = 
  # ==================

  rule listen
    'LISTEN' listen_to_clause via_clause listen_for_clause
  end

  rule listen_to_clause
    s 'TO' s (user / access)
  end
  
  rule listen_for_clause
    s 'FOR' s identifier listen_of_clause?
  end
  
  rule listen_of_clause
    s 'OF' s identifier
  end
  
  
  
  # ==========
  # = Notify =
  # ==========
  
  rule notify
    'NOTIFY' s (user / access) via_clause notify_of_clause
  end

  rule notify_of_clause
    s 'OF' s expression
  end
  
  
  
  # ==============
  # = On Command =
  # ==============
  
  rule on
    'ON' on_each? in_clause 'DO' sn statements? s? 'END'
  end
  
  rule on_each
    s 'EACH' on_each_count?
  end
  
  rule on_each_count
    s integer
  end
  
  
  
  
  # ==================
  # = People Command =
  # ==================
  
  rule user
    me / public / people / person
  end
  
  rule me
    'ME'
  end
  
  rule public
    'PUBLIC'
  end
  
  rule person
    'PERSON' people_from_clause? (people_where_clause)?
  end
  
  rule people
    'PEOPLE' people_from_clause? (people_where_clause)?
  end
  
  # TODO - Add back community list. Right now, you can only access people from 
  # one community at a time...
  rule people_from_clause
    sn 'FROM' sn access
  end

  rule people_where_clause
    sn 'WHERE' sn predicate
  end
  
  rule predicate
    predicate_unary / predicate_binary / predicate_primary
  end 
  
  rule predicate_unary
    not_operator s? '(' s? predicate_primary s? ')'
  end
  
  rule predicate_binary
    predicate_primary s (and_operator / or_operator) s predicate
  end
  
  rule predicate_primary 
    predicate_parenthesis / predicate_conditional
  end 
  
  rule predicate_parenthesis 
    '(' s? predicate s? ')'
  end
  
  rule predicate_conditional
    key_paths s? relational_operator s? access
  end
  
  
  # ===========================
  # = Structure Instantiation =
  # ===========================
  
  rule structure_instantiation
    identifier sn? structure
  end
  
  
  
  # ===============
  # = Definitions =
  # ===============
  
  rule function_definition
    'DEFINE' s identifier function_for? function_on? function_using? s 'DO' sn statements? s? 'END'
  end
  
  rule function_for
    s 'FOR' s identifier
  end
  
  rule function_on
    s 'ON' s identifier_list
  end
  
  rule function_using
    s 'USING' s function_optional_parameters
  end
  
  rule function_optional_parameters
    function_optional_parameter+
  end
  
  rule function_optional_parameter
    s? identifier s? '=' s? expression (s? ',' &function_optional_parameter / '' !function_optional_parameter)
  end
  
  rule structure_definition
    'DEFINE' s identifier sn? '{' sn? structure_property* sn? '}'
  end
  
  rule structure_property
    sn? (identifier s)? (identifier / string / number) (s? '=' s? expression)? s? ((',' / "\n") &structure_property / '' !structure_property)
  end
  
  rule collection_definition
    'DEFINE' s identifier s 'OF' identifier
  end
  
  
  
  
  # ===================
  # = Others Commands =
  # ===================
  
  # TODO
  rule import
  	'IMPORT'
  end
  
  rule print
    'PRINT' space expression
  end
  
  rule inspect
    'INSPECT' space expression
  end
  
  
  
  # ======================
  # = Control Structures =
  # ======================
  
  rule control_structure
    if / for / while / break / return
  end
  
  rule if
    'IF' s expression s 'THEN' sn statements? else_clause? s? 'END'
  end
  
  rule else_clause
    sn? 'ELSE' sn statements?
  end

  rule for
    'FOR' s 'EACH' in_clause 'DO' sn statements? s? ('END' / ('UNTIL' s statement))
  end
  
  rule while
    'WHILE' s expression s 'DO' sn statements? s? 'END'
  end
  
  rule break
    'BREAK'
  end
  
  rule return
    'RETURN' return_expression?
  end
  
  rule return_expression 
    s expression
  end
  
  
  
  # ==================
  # = Shared Clauses =
  # ==================
  
  rule using_clause
	(s 'USING' s (identifier s? '=' s? expression (s? ',' s? identifier s? '=' s? expression)*) )
  end
  
  rule using_clause_content
    identifier_associations / access
  end
  
  rule on_clause
	(s 'ON' s (expression (s? ',' s? expression)*) )
	/
	(s 'ON' s (identifier s? '=' s? expression ( s? ',' s? identifier s? '=' s? expression)*) )
  end
  
  rule via_clause 
    s 'VIA' s identifier
  end
  
  rule in_clause
    s identifier in_clause_expression? s
  end
  
  rule in_clause_expression
    s 'IN' s expression
  end
  
  
  
  # =========
  # = Lists =
  # =========
  
  rule key_paths
    key_path+
  end
  
  rule key_path
    identifier ('.' &key_path / '' !key_path)
  end
  
  # TODO - Add newlines? -- perhaps combine with associations below?
  
  rule identifier_associations
    identifier_association+
  end

  rule identifier_association
    sn? identifier s? ':' s? expression (s? ',' &identifier_association / '' !identifier_association)
  end
  
  rule identifier_list
    identifier_list_item+
  end
  
  rule identifier_list_item
    s? identifier (s? ',' &identifier_list_item / '' !identifier_list_item)
  end
  
  # TODO - combine with items -- perhaps renamed to expresion_list -- add newlines?
  
  rule argument_list
    argument_list_item+
  end
  
  # TODO - To get this to work, I had to move the 's?' into the parenthesis with
  # &argument_list_item. if I try to do that with association i get test errors.
  # is this correct? I also did the same thing with identifier_list and 
  # identifier_association will that break in the future also?
  
  rule argument_list_item
    s? expression (s? ',' &argument_list_item / '' !argument_list_item)
  end
  
  
  
  
  # ================
  # = Dog literals =
  # ================
  
  rule literal
    number / string / bool / structure
  end
  
  # TODO - I am keep this for the future if I choose to include this syntactic sugar
  #rule array 
  #  '[' sn? items? sn? (',' sn?)? ']' <::Dog::Nodes::ArrayLiteral>
  #end
  #
  #rule items
  #  item+ <::Dog::Nodes::ArrayItems>
  #end
  #
  #rule item
  #  sn? expression ((sn? ',' &item) / ('' !item)) <::Dog::Nodes::ArrayItem>
  #end
  
  rule structure
    '{' s? association* (sn? ',' sn?)? s? '}'
  end
  
  rule association 
    sn? (identifier / string / number) s? '=' s? expression sn? ( (',' / "\n") &association / '' !association)
  end
  
  rule string
    (
    '"' ('\"' / !'"' .)* '"'
    /
    '\'' ('\\\'' / !'\'' .)* '\''
    )
  end
  
  rule number
    float / integer
  end
  
  rule integer 
    ('-' s?)? digit+
  end
  
  rule float
    ('-' s?)? digit+ '.' digit*
  end

  rule bool
    (true / false)
  end

  rule true
    ('TRUE' / 'true')
  end

  rule false
    ('FALSE' / 'false') 
  end
  
  
  
  # ===================
  # = Building Blocks =
  # ===================
  
  rule identifier
    lower (lower / digit / '_')*
  end
  
  rule digit
    [0-9]
  end

  rule character
    lower / upper / '_'
  end

  rule lower
    [a-z]
  end

  rule upper
    [A-Z]
  end

  rule t
    terminal
  end

  rule terminal
    (";" / comment / "\n" / end_of_file)
  end

  rule comment
    '#' (!"\n" .)* ("\n" / end_of_file)
  end

  rule sn
    space_newline
  end

  rule space_newline
    (" " / "\t" / "\n" / "\r" / comment)+
  end

  rule s
    space
  end

  rule space
    (" " / "\t")+
  end

  rule end_of_file
    !.
  end

end

end
