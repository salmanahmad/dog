#
# Copyright 2011 by Salman Ahmad (salman@salmanahmad.com).
# All rights reserved.
#
# Permission is granted for use, copying, modification, distribution,
# and distribution of modified versions of this work as long as the
# above copyright notice is included.
#

module Dog

grammar Dog

  # ================
  # = Core Program =
  # ================
  
  rule program
    program_statements / '' <::Dog::Program>
  end
  
  rule program_statements
    (((top_level_statement / statement / s) t) / ("\n" / comment))+ <::Dog::ProgramStatements>
  end
  
  rule statements
    ((statement / s t) / ("\n" / comment))+ <::Dog::Statements>
  end
  
  rule top_level_statement
    (listen / import / config / function) s? <::Dog::TopLevelStatement>
  end
  
  rule statement 
    s? (command / expression) s? <::Dog::Statement>
  end
  
  rule expression
    (assignment / primary)
  end
  
  rule command
     (notify / on / ask / compute / people / control_structure / print / inspect)
  end
  
  # ===============
  # = Expressions =
  # ===============
  
  rule assignment
    lhs s? assignment_operator s? (ask / notify / compute / people) <::Dog::Assignment>
    / 
    lhs s? assignment_operator s? primary <::Dog::Assignment>
  end

  rule primary
    operation / access / literal / identifier / ('(' s? primary s? ')') <::Dog::Primary>
  end
  
  rule operation
    operation_first s? binary_operator s? (operation / operation_first) <::Dog::Operation>
    / 
    unary_operator s primary <::Dog::Operation>
  end
  
  rule operation_first
    literal / access / identifier / '(' s? primary s? ')' <::Dog::Primary>
  end
  
  rule access
    access_first access_tail <::Dog::Access>
  end
  
  rule access_first
    literal / identifier / '(' s? primary s? ')' / ('(' s operation s ')')
  end
  
  rule access_tail
    access_dot / access_bracket / access_possessive
  end
  
  rule access_dot
    '.' identifier access_tail? <::Dog::AccessDot>
  end
  
  rule access_bracket
    s? '[' s? primary s? ']' s? access_tail? <::Dog::AccessBracket>
  end
  
  rule access_possessive
    ('\'s' / '\'') s identifier access_tail? <::Dog::AccessPossessive>
  end
  
  
  
  
  
  
  
  
  
  
  
  
  
  rule lhs
    (access / identifier)
  end
  
  rule identifier
    lower (lower / digit / '_')* <::Dog::Identifier>
  end

  rule binary_operator
    (arithmetic_operator / collection_operator / comparative_operator / and_operator / or_operator)
  end
  
  rule unary_operator
    (not_operator)
  end
  
  rule assignment_operator
    '=' <::Dog::AssignmentOperator>
  end
  
  rule arithmetic_operator
    (addition_operator / subtraction_operator / multiplication_operator / division_operator)
  end
  
  rule comparative_operator
    (equality_operator / inequality_operator / greater_than_operator / less_than_operator / greater_than_equal_operator / less_than_equal_operator / associates_operator / contains_operator)
  end
  
  rule logical_operator
    (and_operator / or_operator / not_operator)
  end
  
  rule collection_operator
    union_operator / intersect_operator / difference_operator / append_operator / prepend_operator
  end
  
  rule addition_operator
    '+' <::Dog::AdditionOperator>
  end
  
  rule subtraction_operator
    '-' <::Dog::SubtractionOperator>
  end
  
  rule multiplication_operator
    '*' <::Dog::MultiplicationOperator>
  end
  
  rule division_operator
    '/' <::Dog::DivisionOperator>
  end
  
  rule equality_operator
    '==' <::Dog::EqualityOperator>
  end
  
  rule inequality_operator
    '!=' <::Dog::InequalityOperator>
  end
  
  rule greater_than_operator
    '>' <::Dog::GreaterThanOperator>
  end
  
  rule less_than_operator
    '<' <::Dog::LessThanOperator>
  end
  
  rule greater_than_equal_operator
    '>=' <::Dog::GreaterThanEqualOperator>
  end
  
  rule less_than_equal_operator
    '<=' <::Dog::LessThanEqualOperator>
  end
  
  rule and_operator
    'AND' <::Dog::AndOperator>
  end
  
  rule or_operator
    'OR' <::Dog::OrOperator>
  end
  
  rule not_operator
    'NOT' <::Dog::NotOperator>
  end
  
  rule union_operator
    'UNION' <::Dog::UnionOperator>
  end
  
  rule intersect_operator
    'INTERSECT' <::Dog::IntersectOperator>
  end
  
  rule difference_operator
    ('DIFFERENCE' / 'DIFF' / 'MINUS') <::Dog::DifferenceOperator>
  end
  
  rule append_operator
    'APPEND' <::Dog::AppendOperator>
  end
  
  rule prepend_operator
    'PREPEND' <::Dog::PrependOperator>
  end
  
  rule associates_operator
    "ASSOCIATES" <::Dog::AssociatesOperator>
  end
  
  rule contains_operator
    "CONTAINS" <::Dog::ContainsOperator>
  end
  
  
  
  # ==================
  # = Listen Command = 
  # ==================

  rule listen
    'LISTEN' listen_to_clause via_clause listen_at_clause? listen_for_clause
  end

  rule listen_to_clause
    s 'TO' s (user / identifier)
  end

  rule listen_for_clause
    s 'FOR' s identifier
  end

  rule listen_at_clause
    s 'AT' s string
  end



  # ===============
  # = Ask Command =
  # ===============

  rule ask
    'ASK' sn (integer sn)? (user / identifier) via_clause sn 'TO' sn ask_function on_clause? using_clause?
  end

  rule ask_function
    identifier
  end



  # ==========
  # = Notify =
  # ==========

  rule notify
    'NOTIFY' s (user / identifier) via_clause notify_of_clause using_clause?
  end

  rule notify_of_clause
    s 'OF' s (access / identifier / string)
  end



  # ===================
  # = Compute Command =
  # ===================

  rule compute
    'COMPUTE' s identifier on_clause? using_clause?
  end



  # ==================
  # = Shared Clauses =
  # ==================

  rule using_clause
    s 'USING' s assignment_list
  end

  # TODO - Consolidate this logic with the array items rule. See that TODO as well.
  rule on_clause 
    s ('ON' s)? on_clause_items
  end

  rule on_clause_items 
    sn? primary (sn? ',' sn? primary)*
  end

  rule via_clause 
    (s 'VIA' s identifier)
  end

  rule in_clause
    s ((identifier s 'IN' s primary) / identifier) s
  end



  # ==================
  # = People Command =
  # ==================

  rule user
    (me / public / people)
  end

  rule me
    ('ME')
  end

  rule public
    ('PUBLIC')
  end

  rule people
    ('PEOPLE' / 'PERSON') people_from_clause (people_where_clause)?
  end

  rule people_from_clause
    sn 'FROM' sn (community_list / primary)
  end

  rule people_where_clause
    sn 'WHERE' sn predicate
  end
  
  rule predicate
    predicate_unary / predicate_binary / predicate_primary
  end 
  
  rule predicate_unary
    not_operator s? '(' s? predicate_primary s? ')'
  end
  
  rule predicate_binary
    predicate_primary (s (and_operator / or_operator) s predicate)
  end
  
  rule predicate_primary 
    predicate_parenthesis / predicate_conditional
  end 
  
  rule predicate_parenthesis 
    ('(' s? predicate s? ')')
  end
  
  rule predicate_conditional
    (key_path s? comparative_operator s? primary)
  end
  
  rule key_path
    identifier ('.' identifier)*
  end



  # ==============
  # = On Command =
  # ==============
  
  rule on
    'ON' (s 'EACH' (s integer)?)? in_clause 'DO' sn statements? s? 'END'
  end
  
  
  
  # ===================
  # = Others Commands =
  # ===================
  
  # TODO - Support for primaries instead of literals
  rule config
    'CONFIG' s identifier s '=' s literal <::Dog::Config>
  end
  
  rule function
    'DEFINE' s identifier (s 'ON' s function_parameters)? (s 'USING' s function_optional_parameters)? s? 'DO' sn statements? 'END'
  end
  
  rule function_parameters
    function_parameter (',' function_parameter)*
  end
  
  rule function_parameter
    sn? identifier sn?
  end
  
  rule function_optional_parameters
    function_optional_parameter (',' function_optional_parameter)*
  end
  
  rule function_optional_parameter
    sn? identifier (s? '=' s? literal) sn?
  end
  
  rule import 
    'IMPORT' s type:(import_function / import_data / import_community / import_task / import_message / import_config) s string (s 'AS' s identifier)? <::Dog::Import>
  end
  
  rule import_function
    'FUNCTION' <::Dog::ImportFunction>
  end
  
  rule import_data
    'DATA' <::Dog::ImportData>
  end
  
  rule import_community
    'COMMUNITY' <::Dog::ImportCommunity>
  end
  
  rule import_task
    'TASK' <::Dog::ImportTask>
  end
  
  rule import_message
    'MESSAGE' <::Dog::ImportMessage>
  end
  
  rule import_config
    'CONFIG' <::Dog::ImportConfig>
  end
  
  # TODO - Remove me
  rule parameters
    ('PARAMETERS' space_newline ('WITH' space_newline assignment_list)? ) <Parameters>
  end
  
  rule print
    ('PRINT' space primary) <Print>
  end
  
  rule inspect
    ('INSPECT' space primary) <Inspect>
  end



  # =========
  # = Lists =
  # =========

  rule community_list
    (string (sn 'AND' sn string)*)
  end

  rule assignment_list
    assignment_list_assignment ( sn? (',' / 'AND') sn? assignment_list_assignment)*
  end

  rule assignment_list_assignment
    (identifier s? ':' s? primary)
  end



  # ======================
  # = Control Structures =
  # ======================

  rule control_structure
    (if / for / repeat / break)
  end

  rule repeat
    'REPEAT' s integer s 'DO' sn statements? s? 'END' <::Dog::Repeat>
  end

  rule if
    'IF' s primary s 'THEN' sn statements? (sn 'ELSE' sn statements?)? s? 'END' <::Dog::If>
  end

  rule for
    'FOR' s 'EACH' in_clause 'DO' sn statements? s? ('END' / ('UNTIL' s primary)) <::Dog::For>
  end
  
  rule break
    'BREAK' <::Dog::Break>
  end
  


  # ================
  # = Dog literals =
  # ================

  rule literal
    (number / string / bool / collection)
  end

  rule collection
    (array / hash)
  end

  rule array 
    '[' s? items? ']' <::Dog::ArrayLiteral>
  end

  rule items
    item+ <::Dog::ArrayItems>
  end
  
  # TODO - Remove the ? from comman
  rule item
    sn? primary sn? ','? <::Dog::ArrayItem>
  end
  
  rule hash 
    (identifier s?)? '{' associations? '}' <::Dog::HashLiteral>
  end

  rule associations
    association+ <::Dog::HashAssociations>
  end

  # TODO - Remove the comma
  rule association 
    sn? key:string s? ':' s? value:primary sn? ','? <::Dog::HashAssociation>
  end

  rule bool
    (true / false)
  end

  rule true
    (
      'TRUE' <::Dog::TrueLiteral>
      / 
      'true' <::Dog::TrueLiteral>
      /
      'YES' <::Dog::TrueLiteral>
      /
      'yes' <::Dog::TrueLiteral>
    ) 
  end

  rule false
    (
      'FALSE' <::Dog::FalseLiteral>
      / 
      'false' <::Dog::FalseLiteral>
      / 
      'NO' <::Dog::FalseLiteral>
      / 
      'no' <::Dog::FalseLiteral>
    ) 
  end

  rule number
    float / integer
  end

  rule integer 
    ('-' s?)? digit+ <::Dog::IntegerLiteral>
  end

  rule float
    ('-' s?)? digit+ '.' digit* <::Dog::FloatLiteral>
  end

  rule string
    (
    '"' ('\"' / !'"' .)* '"' <::Dog::StringLiteral>
    /
    '\'' ('\\\'' / !'\'' .)* '\'' <::Dog::StringLiteral>
    )
  end

  rule digit
    [0-9]
  end

  rule character
    lower / upper / '_'
  end

  rule lower
    [a-z]
  end

  rule upper
    [A-Z]
  end

  rule t
    terminal
  end

  rule terminal
    (";" / comment / "\n" / end_of_file)
  end

  rule comment
    '#' [^"\n"]* ("\n" / end_of_file)
  end

  rule sn
    space_newline
  end

  rule space_newline
    (" " / "\t" / "\n" / "\r" / comment)+
  end

  rule s
    space
  end

  rule space
    (" " / "\t")+
  end

  rule end_of_file
    !.
  end

end

end
