#
# Copyright 2011 by Salman Ahmad (salman@salmanahmad.com).
# All rights reserved.
#
# Permission is granted for use, copying, modification, distribution,
# and distribution of modified versions of this work as long as the
# above copyright notice is included.
#

# TODO - REPEAT
# TODO - Define functions
# CHECK - Comments

module Dog

grammar Dog

  # ================
  # = Core Program =
  # ================
  
  rule program
    program_statements
  end
  
  rule program_statements
    (top_level_statements / statements)
  end
  
  rule top_level_statements
    (top_level_statement t)+ 
  end
  
  rule top_level_statement
    (listen / import / config)
  end
  
  rule statements
    ((statement t)+)
  end

  rule statement 
    (s? (command / expression / '' ) s?)
  end

  rule expression
    (assignment / primary)
  end

  rule command
     (on / ask / notify / compute / people / control_structure / print / inspect)
  end

  # ===============
  # = Expressions =
  # ===============

  rule assignment
    (lhs s? assignment_operator s? (ask / compute / people)) / (lhs s? assignment_operator s? primary)
  end

  rule primary
    access / operation / literal / identifier / ('(' s? primary s? ')')
  end
  
  rule operation
    ((operation_first s binary_operator s (operation / operation_first)) / (unary_operator s primary))
  end
  
  rule operation_first
    (literal / identifier / ('(' s? primary s? ')') / access)
  end

  rule access
    (access_first ('.' identifier)+) / (access_first ('[' s? primary s? ']')+) / (access_first (('\'s' / '\'') s identifier)+)
  end

  rule access_first
    (literal / identifier / ('(' s? primary s? ')') / ('(' s operation s ')'))
  end

  rule lhs
    (access / identifier)
  end
  
  rule identifier
    lower (lower / digit / '_')* <::Dog::Identifier>
  end

  rule binary_operator
    (arithmetic_operator / collection_operator / comparative_operator / and_operator / or_operator)
  end
  
  rule unary_operator
    (not_operator)
  end
  
  rule assignment_operator
    '=' <::Dog::AssignmentOperator>
  end
  
  rule arithmetic_operator
    (addition_operator / subtraction_operator / multiplication_operator / division_operator)
  end
  
  rule comparative_operator
    (equality_operator / inequality_operator / greater_than_operator / less_than_operator / greater_than_equal_operator / less_than_equal_operator / associates_operator / contains_operator)
  end
  
  rule logical_operator
    (and_operator / or_operator / not_operator)
  end
  
  rule collection_operator
    union_operator / intersect_operator / difference_operator / append_operator / prepend_operator
  end
  
  rule addition_operator
    '+' <::Dog::AdditionOperator>
  end
  
  rule subtraction_operator
    '-' <::Dog::SubtractionOperator>
  end
  
  rule multiplication_operator
    '*' <::Dog::MultiplicationOperator>
  end
  
  rule division_operator
    '/' <::Dog::DivisionOperator>
  end
  
  rule equality_operator
    '==' <::Dog::EqualityOperator>
  end
  
  rule inequality_operator
    '!=' <::Dog::InequalityOperator>
  end
  
  rule greater_than_operator
    '>' <::Dog::GreaterThanOperator>
  end
  
  rule less_than_operator
    '<' <::Dog::LessThanOperator>
  end
  
  rule greater_than_equal_operator
    '>=' <::Dog::GreaterThanEqualOperator>
  end
  
  rule less_than_equal_operator
    '<=' <::Dog::LessThanEqualOperator>
  end
  
  rule and_operator
    'AND' <::Dog::AndOperator>
  end
  
  rule or_operator
    'OR' <::Dog::OrOperator>
  end
  
  rule not_operator
    'NOT' <::Dog::NotOperator>
  end
  
  rule union_operator
    'UNION' <::Dog::UnionOperator>
  end
  
  rule intersect_operator
    'INTERSECT' <::Dog::IntersectOperator>
  end
  
  rule difference_operator
    ('DIFFERENCE' / 'DIFF' / 'MINUS') <::Dog::DifferenceOperator>
  end
  
  rule append_operator
    'APPEND' <::Dog::AppendOperator>
  end
  
  rule prepend_operator
    'PREPEND' <::Dog::PrependOperator>
  end
  
  rule associates_operator
    "ASSOCIATES" <::Dog::AssociatesOperator>
  end
  
  rule contains_operator
    "CONTAINS" <::Dog::ContainsOperator>
  end
  
  
  
  # ==================
  # = Listen Command = 
  # ==================

  rule listen
    ('LISTEN' listen_to_clause listen_for_clause listen_at_clause) <Listen>
  end

  rule listen_to_clause
    (s 'TO' s (people / identifier)) <ListenToClause>
  end

  rule listen_for_clause
    (s 'FOR' s identifier) <ListenForClause>
  end

  rule listen_at_clause
    (s 'AT' s string) <ListenAtClause>
  end



  # ===============
  # = Ask Command =
  # ===============

  rule ask
    ('ASK' sn (integer sn)? (users / identifier) via_clause? sn 'TO' sn ask_function on_clause? (using_clause)? )
  end

  rule ask_function
    (identifier / string)
  end



  # ==========
  # = Notify =
  # ==========

  rule notify
    ('NOTIFY' s (identifier / people) via_clause? notify_of_clause using_clause?) <Notify>
  end

  rule notify_of_clause
    (s 'OF' s (identifier / string)) <NotifyOfClause>
  end



  # ===================
  # = Compute Command =
  # ===================

  rule compute
    ('COMPUTE' s identifier on_clause? using_clause? ) <Compute>
  end



  # ==================
  # = Shared Clauses =
  # ==================

  rule using_clause
    (s 'USING' s (parameters / assignment_list / identifier)) <UsingClause>
  end

  rule on_clause 
    (s ('ON' s)? primary) <OnClause>
  end

  rule via_clause 
    (s 'VIA' s ('email' / 'im' / 'sms')) <ViaClause>
  end

  rule in_clause
    (s ((identifier s 'IN' s primary) / identifier) s) <InClause>
  end



  # ==================
  # = People Command =
  # ==================

  rule users
    (me / public / people)
  end

  rule me
    ('ME')
  end

  rule public
    ('PUBLIC')
  end

  rule people
    (('PEOPLE' / 'PERSON') people_from_clause (people_where_clause)? ) <People>
  end

  rule people_from_clause
    (sn 'FROM' sn (community_list / primary)) <PeopleFromClause>
  end

  rule people_where_clause
    (sn 'WHERE' sn predicate) <PeopleWhereClause>
  end
  
  rule predicate
    predicate_unary / predicate_binary / predicate_primary
  end 
  
  rule predicate_unary
    not_operator s? '(' s? predicate_primary s? ')'
  end
  
  rule predicate_binary
    predicate_primary (s (and_operator / or_operator) s predicate)
  end
  
  rule predicate_primary 
    predicate_parenthesis / predicate_conditional
  end 
  
  rule predicate_parenthesis 
    ('(' s? predicate s? ')')
  end
  
  rule predicate_conditional
    (key_path s? comparative_operator s? primary)
  end
  
  rule key_path
    identifier ('.' identifier)*
  end



  # ==============
  # = On Command =
  # ==============

  rule on
    ('ON' in_clause 'DO' sn statements sn? 'END') <OnBlock>
  end



  # ===================
  # = Others Commands =
  # ===================
  
  # TODO - Support for primaries instead of literals
  rule config
    'CONFIG' s identifier s '=' s literal <::Dog::Config>
  end
  
  rule import 
    'IMPORT' s type:(import_function / import_data / import_community / import_task / import_message / import_config) s string (s 'AS' s identifier)? <::Dog::Import>
  end
  
  rule import_function
    'FUNCTION' <::Dog::ImportFunction>
  end
  
  rule import_data
    'DATA' <::Dog::ImportData>
  end
  
  rule import_community
    'COMMUNITY' <::Dog::ImportCommunity>
  end
  
  rule import_task
    'TASK' <::Dog::ImportTask>
  end
  
  rule import_message
    'MESSAGE' <::Dog::ImportMessage>
  end
  
  rule import_config
    'CONFIG' <::Dog::ImportConfig>
  end
  
  rule parameters
    ('PARAMETERS' space_newline ('WITH' space_newline assignment_list)? ) <Parameters>
  end
  
  rule print
    ('PRINT' space primary) <Print>
  end
  
  rule inspect
    ('INSPECT' space primary) <Inspect>
  end



  # =========
  # = Lists =
  # =========

  rule community_list
    (string (sn 'AND' sn string)*)
  end

  rule assignment_list
    (assignment_list_assignment sn ((',' / 'AND') sn assignment_list_assignment)*)
  end

  rule assignment_list_assignment
    (identifier s '=' s primary)
  end



  # ======================
  # = Control Structures =
  # ======================

  rule control_structure
    (if / for)
  end

  rule if
    ('IF' s primary (s 'THEN')? sn statements sn 'END') <If>
  end

  rule for
    ('FOR' s 'EACH' in_clause 'DO' sn statements sn? ('END' / ('UNTIL' s primary))) <For>
  end



  # ================
  # = Dog literals =
  # ================

  rule literal
    (number / string / bool / collection)
  end

  rule collection
    (array / hash)
  end

  rule array 
    '[' items? ']' <::Dog::ArrayLiteral>
  end

  rule items
    item+ <::Dog::ArrayItems>
  end
  
  rule item
    sn? primary sn? ','? <::Dog::ArrayItem>
  end
  
  rule hash 
    (identifier s?)? '{' associations? '}' <::Dog::HashLiteral>
  end

  rule associations
    association+ <::Dog::HashAssociations>
  end

  rule association 
    sn? key:string s? ':' s? value:primary sn? ','? <::Dog::HashAssociation>
  end

  rule bool
    (true / false)
  end

  rule true
    (
      'TRUE' <::Dog::TrueLiteral>
      / 
      'true' <::Dog::TrueLiteral>
      /
      'YES' <::Dog::TrueLiteral>
      /
      'yes' <::Dog::TrueLiteral>
    ) 
  end

  rule false
    (
      'FALSE' <::Dog::FalseLiteral>
      / 
      'false' <::Dog::FalseLiteral>
      / 
      'NO' <::Dog::FalseLiteral>
      / 
      'no' <::Dog::FalseLiteral>
    ) 
  end

  rule number
    float / integer
  end

  rule integer 
    ('-' s?)? digit+ <::Dog::IntegerLiteral>
  end

  rule float
    ('-' s?)? digit+ '.' digit* <::Dog::FloatLiteral>
  end

  rule string
    (
    '"' ('\"' / !'"' .)* '"' <::Dog::StringLiteral>
    /
    '\'' ('\\\'' / !'\'' .)* '\'' <::Dog::StringLiteral>
    )
  end

  rule digit
    [0-9]
  end

  rule character
    lower / upper / '_'
  end

  rule lower
    [a-z]
  end

  rule upper
    [A-Z]
  end

  rule t
    terminal
  end

  rule terminal
    (";" / "\n" / end_of_file / comment)
  end
  
  rule comment
    '#' .* '\n'
  end
  
  rule sn
    space_newline
  end

  rule space_newline
    [ \t\n\r]+
  end

  rule s
    space
  end

  rule space
    [ \t]+
  end
  
  rule end_of_file
    !.
  end

end

end
