#
# Copyright 2011 by Salman Ahmad (salman@salmanahmad.com).
# All rights reserved.
#
# Permission is granted for use, copying, modification, distribution,
# and distribution of modified versions of this work as long as the
# above copyright notice is included.
#

module Dog

grammar Dog

  # ================
  # = Core Program =
  # ================

  rule program
    statements
    / 
    ''
  end
  
  rule statements
    statement+ {
      def transform
        nodes = ::Dog::Nodes::Nodes.new []
        nodes.line = self.line
        
        nodes.nodes = []
        
        if elements then
          for element in elements do
            element = element.transform
            nodes.nodes << element if element
          end
        end
        
        return nodes
      end  
    }
  end
  
  rule statement
    s? expression s? t {
      def transform
        return self.expression.transform
      end
    }
    /
    s t
    / 
    "\n"
    /
    ";"
    /
    comment
  end
  
  
  
  # ===============
  # = Expressions =
  # ===============
  
  rule expression
    assignment_expression
  end
  
  rule assignment_expression
    assignment
    /
    match_expression
  end
  
  rule match_expression
    left:(or_expression) s? match_operator s? right:(or_expression) {
      def transform
        node = ::Dog::Nodes::Operation.new(left.transform, right.transform, match_operator.transform)
        node.line = self.line
        
        return node
      end
    }
    /
    or_expression
  end
  
  rule or_expression
    and_expression s or_operator s or_expression {
      def transform
        node = ::Dog::Nodes::Operation.new(and_expression.transform, or_expression.transform, or_operator.transform)
        node.line = self.line
        
        return node
      end
    }
    /
    and_expression
  end
  
  rule and_expression
    relational_expression s and_operator s and_expression {
      def transform
        node = ::Dog::Nodes::Operation.new(relational_expression.transform, and_expression.transform, and_operator.transform)
        node.line = self.line
        
        return node
      end
    }
    /
    relational_expression
  end
  
  rule relational_expression
    additive_expression s? relational_operator s? relational_expression {
      def transform
        node = ::Dog::Nodes::Operation.new(additive_expression.transform, relational_expression.transform, relational_operator.transform)
        node.line = self.line
        
        return node
      end
    }
    /
    additive_expression
  end
  
  rule additive_expression
    multiplicative_expression s? additive_operator s? additive_expression {
      def transform
        node = ::Dog::Nodes::Operation.new(multiplicative_expression.transform, additive_expression.transform, additive_operator.transform)
        node.line = self.line
        
        return node
      end
    }
    /
    multiplicative_expression
  end
  
  rule multiplicative_expression
    unary_expression s? multiplicative_operator s? multiplicative_expression {
      def transform
        node = ::Dog::Nodes::Operation.new(unary_expression.transform, multiplicative_expression.transform, multiplicative_operator.transform)
        node.line = self.line
        
        return node
      end
    }
    /
    unary_expression
  end
  
  rule unary_expression
    unary_operator s unary_expression {
      def transform
        node = ::Dog::Nodes::Operation.new(unary_expression.transform, nil, unary_operator.transform)
        node.line = self.line
        
        return node
      end
    }
    /
    query_expression
  end
  
  rule query_expression
    primary_expression s 'FROM' s community:(primary_expression) s predicate {
      def transform
        
        structure = ::Dog::Nodes::StructureLiteral.new(nil, {
          "$and" => ::Dog::Nodes::StructureLiteral.new(::Dog::Nodes::Access.new(["dog", "array"]), {
            0 => ::Dog::Nodes::StructureLiteral.new(nil, {
              "value.s:communities.value.value" => ::Dog::Nodes::Access.new([community.transform, "name"])
            }),
            1 => predicate.transform,
          })
        })
        
        node = ::Dog::Nodes::StructureLiteral.new(::Dog::Nodes::Access.new(["dog", "query"]), {
          "container" => primary_expression.transform,
          "predicate" => structure
        })
        node.line = self.line
        
        return node
      end
    }
    / 
    primary_expression s 'FROM' s community:(primary_expression) {
      def transform
        
        structure = ::Dog::Nodes::StructureLiteral.new(nil, {
          "value.s:communities.value.value" => ::Dog::Nodes::Access.new([community.transform, "name"])
        })
        
        node = ::Dog::Nodes::StructureLiteral.new(::Dog::Nodes::Access.new(["dog", "query"]), {
          "container" => primary_expression.transform,
          "predicate" => structure
        })
        node.line = self.line
        
        return node
      end
    }
    / 
    primary_expression s predicate {
      def transform
        node = ::Dog::Nodes::StructureLiteral.new(::Dog::Nodes::Access.new(["dog", "query"]), {
          "container" => primary_expression.transform,
          "predicate" => predicate.transform
        })
        node.line = self.line
        
        return node
      end
    }
    /
    primary_expression
  end
  
  rule primary_expression
    access
    /
    compute
    /
    ask
    /
    listen
    /
    display
    /
    notify
    /
    function_definition
    /
    structure_definition
    /
    collection_definition
    /
    community_definition
    /
    control_structure
    /
    perform
    /
    import
    /
    package
    /
    print
    /
    inspect
    /
    wait
    /
    spawn
    /
    time_construct
    /
    on_each
    /
    on
    /
    person
    /
    predicate
    /
    add
    /
    find
    /
    update
    /
    save
    /
    remove
    /
    delete
  end
  
  # ==============
  # = Assignment =
  # ==============
  
  rule assignment
    scope:(scope:('external' / 'internal' / 'local') s)? assignment_access s? assignment_operator s? expression {
      def transform
        node = ::Dog::Nodes::Assign.new(assignment_access.transform, expression.transform)
        node.line = self.line
        
        if !self.scope.empty? then
          node.scope = self.scope.scope.text_value
        end
        
        return node
      end
    }
  end
  
  rule assignment_access
    identifier access_tail:(access_tail)? {
      def transform
        if !access_tail.empty? then
          return access_tail.transform.clone.unshift(identifier.text_value)
        else
          return [identifier.text_value]
        end
      end
    }
  end
  
  rule access
    scope:(scope:('external' / 'internal' / 'local') s)? access_head access_tail:(access_tail)? {
      def transform
        if !access_tail.empty? then
          path = access_tail.transform.clone.unshift(access_head.transform)
        else
          path = [access_head.transform]
        end
        
        node = ::Dog::Nodes::Access.new(path)
        node.line = self.line
        
        if !self.scope.empty? then
          node.scope = self.scope.scope.text_value
        end
        
        return node
      end
    }
  end
  
  rule access_head
    literal
    /
    identifier {
      def transform
        return self.text_value
      end
    }
    / 
    '(' sn? expression sn? ')' {
      def transform
        return expression.transform
      end
    }
  end
  
  rule access_tail
    access_dot
    / 
    access_bracket
  end
  
  rule access_dot
    '.' identifier access_tail:(access_tail)? {
      def transform
        if !access_tail.empty? then
          return access_tail.transform.clone.unshift(identifier.text_value)
        else
          return [identifier.text_value]
        end
      end
    }
  end
  
  rule access_bracket
    '[' s? expression s? ']' access_tail:(access_tail)? {
      def transform
        if !access_tail.empty? then
          return access_tail.transform.clone.unshift(expression.transform)
        else
          return [expression.transform]
        end
      end
    }
  end
  
  
  
  # =============
  # = Operators =
  # =============
  
  rule assignment_operator
    '=' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule relational_operator
    equality_operator
    /
    identity_operator
    / 
    inequality_operator
    / 
    greater_than_equal_operator
    / 
    less_than_equal_operator
    / 
    greater_than_operator
    / 
    less_than_operator
  end
  
  rule additive_operator
    addition_operator 
    / 
    subtraction_operator
  end
  
  rule multiplicative_operator
    multiplication_operator 
    / 
    division_operator
  end
  
  rule unary_operator
    not_operator
  end
  
  rule addition_operator
    '+' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule subtraction_operator
    '-' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule multiplication_operator
    '*' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule division_operator
    '/' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule equality_operator
    '==' {
      def transform
        return self.text_value
      end
    }
  end
  
  
  rule identity_operator
    '===' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule inequality_operator
    '!=' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule greater_than_operator
    '>' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule less_than_operator
    '<' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule greater_than_equal_operator
    '>=' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule less_than_equal_operator
    '<=' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule and_operator
    'AND' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule or_operator
    'OR' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule not_operator
    'NOT' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule match_operator
    '?' {
      def transform
        return self.text_value
      end
    }
  end
  
  
  # ===================
  # = Compute Command =
  # ===================
  
  rule compute
    'COMPUTE' s packaged_identifier parameters:(s parameter_name s expression)* {
      def transform
        function = packaged_identifier.transform
        
        function_name = [function.path.pop]
        arguments = []
        
        if !parameters.empty? then
          for parameter in parameters.elements do
            function_name << parameter.parameter_name.text_value.downcase
            arguments << parameter.expression.transform
          end
        end
        
        function.path << function_name.join(":")
        
        node = ::Dog::Nodes::Call.new(
          function,
          arguments
        )
        node.line = self.line
        
        return node
      end
    }
  end
  
  
  
  # ===============
  # = Ask Command =
  # ===============
  
  rule ask
    'ASK' sn expression sn 'TO' sn packaged_identifier parameters:(sn parameter_name sn expression)* {
      def transform
        function = packaged_identifier.transform
        
        function_name = [function.path.pop, "for"]
        arguments = [expression.transform]
        
        if !parameters.empty? then
          for parameter in parameters.elements do
            function_name << parameter.parameter_name.text_value.downcase
            arguments << parameter.expression.transform
          end
        end
        
        function.path << function_name.join(":")
        
        node = ::Dog::Nodes::Call.new(
          function,
          arguments
        )
        node.line = self.line
        
        return node
      end
    }
  end
  
  
  
  # ==================
  # = Listen Command = 
  # ==================
  
  rule listen
    'LISTEN' sn 'TO' sn expression listen_for_clause {
      def transform
        # TODO - Update for v0.3
        return
        
        query = listen_to_clause.transform
        for_clause = listen_for_clause.transform
        
        if via_clause.empty?
          via = ::Dog::Nodes::NullLiteral.new
        else
          via = via_clause.transform
        end
        
        variable_name = for_clause.first
        type = for_clause.last
        
        if type.nil? then
          string_value = ::Dog::Value.new("dog.type", {})
          string_value["name"] = ::Dog::Value.string_value("string")
          string_value["package"] = ::Dog::Value.string_value("system")
          string_value = ::Dog::Nodes::ValueLiteral.new(string_value)
          structure_value = ::Dog::Nodes::Access.new([::Dog::Language::singularize(variable_name)])
          type = ::Dog::Nodes::Branch.new(
            ::Dog::Nodes::Operation.new(
              structure_value,
              ::Dog::Nodes::NullLiteral.new,
              "=="
            ),
            ::Dog::Nodes::Nodes.new([
              string_value
            ]),
            ::Dog::Nodes::Nodes.new([
              structure_value
            ])
          )
        end
        
        node = ::Dog::Nodes::Assign.new(
          [variable_name],
          ::Dog::Nodes::Call.new(
            ::Dog::Nodes::Access.new(["dog", "listen"]),
            [type, query, via]
          )
        )
        node.line = self.line
        
        return node
      end
    }
  end
  
  
  rule listen_for_clause
    s 'FOR' s identifier listen_of_clause:(listen_of_clause)? {
      def transform
        # TODO - I need to support inline structure definitions here as well...
        
        if !listen_of_clause.empty?
          return [identifier.text_value, listen_of_clause.transform]
        else
          return [identifier.text_value, nil]
        end
      end
    }
  end
  
  rule listen_of_clause
    s 'OF' s packaged_identifier {
      def transform
        return packaged_identifier.transform
      end
    }
  end
  
  
  
  rule display
    'DISPLAY' sn identifier sn 'TO' sn expression {
      def transform
        # TODO - Update for v0.3
        return
      end
    }
  end
  
  
  # ==========
  # = Notify =
  # ==========
  
  rule notify
    'NOTIFY' s expression via_clause notify_of_clause {
      def transform
        node = ::Dog::Nodes::Call.new(
          ::Dog::Nodes::Access.new(["dog", "notify"]),
          [notify_of_clause.transform, expression.transform, via_clause.transform]
        )
        node.line = self.line
        
        return node
      end
    }
  end
  
  rule notify_of_clause
    s 'OF' s expression {
      def transform
        return expression.transform
      end
    }
  end
  
  
  
  
  # ==================================
  # = Predicates and Queries Command =
  # ==================================
  
  rule person
    'PERSON' people_from_clause {
      def transform
        node = ::Dog::Nodes::Call.new(
          ::Dog::Nodes::Access.new(["system", "person_from_value"]),
          [people_from_clause.transform]
        )
        node.line = self.line
        
        return node
      end
    }
  end
  
  rule people_from_clause
    sn 'FROM' sn expression {
      def transform
        expression.transform
      end
    }
  end
  
  rule predicate
    'WHERE' sn predicate_expression {
      def transform
        node = predicate_expression.transform
        
        return node
      end
    }
  end
  
  rule predicate_expression
    predicate_unary
    /
    predicate_binary
    /
    predicate_primary
  end 
  
  rule predicate_unary
    not_operator s? '(' s? predicate_primary s? ')' {
      def transform
        # TODO - Update for v0.3
        # TODO - The problem here is that I may have to re-write the mongo query...
        return
      end
    }
  end

  rule predicate_binary
    first:predicate_primary s binary_operator:(and_operator / or_operator) s second:predicate_expression {
      def transform
        operator = binary_operator.transform

        case operator
        when "AND"
          structure = ::Dog::Nodes::StructureLiteral.new(nil, {
            "$and" => ::Dog::Nodes::StructureLiteral.new(::Dog::Nodes::Access.new(["dog", "array"]), {
              0 => first.transform,
              1 => second.transform,
            })
          })
        when "OR"
          structure = ::Dog::Nodes::StructureLiteral.new(nil, {
            "$or" => ::Dog::Nodes::StructureLiteral.new(::Dog::Nodes::Access.new(["dog", "array"]), {
              0 => first.transform,
              1 => second.transform,
            })
          })
        else
          raise "Parse error"
        end

        node = structure #::Dog::Nodes::StructureLiteral.new(nil, structure)
        node.line = self.line
        
        return node
      end
    }
  end

  rule predicate_primary 
    predicate_parenthesis / predicate_conditional
  end 

  rule predicate_parenthesis 
    '(' s? predicate_expression s? ')' {
      def transform
        predicate_expression.transform
      end
    }
  end

  rule predicate_conditional
    key_paths s? relational_operator s? expression:(access) {
      def transform
        operator = relational_operator.transform

        case operator
        when "!="
          structure = ::Dog::Nodes::StructureLiteral.new(nil, {
            key_paths.transform => ::Dog::Nodes::StructureLiteral.new(nil, {
              "$ne" => expression.transform
            })
          })
        when ">="
          structure = ::Dog::Nodes::StructureLiteral.new(nil, {
            key_paths.transform => ::Dog::Nodes::StructureLiteral.new(nil, {
              "$gte" => expression.transform
            })
          })
        when "<="
          structure = ::Dog::Nodes::StructureLiteral.new(nil, {
            key_paths.transform => ::Dog::Nodes::StructureLiteral.new(nil, {
              "$lte" => expression.transform
            })
          })
        when ">"
          structure = ::Dog::Nodes::StructureLiteral.new(nil, {
            key_paths.transform => ::Dog::Nodes::StructureLiteral.new(nil, {
              "$gt" => expression.transform
            })
          })
        when "<"
          structure = ::Dog::Nodes::StructureLiteral.new(nil, {
            key_paths.transform => ::Dog::Nodes::StructureLiteral.new(nil, {
              "$lt" => expression.transform
            })
          })
        else
          structure = ::Dog::Nodes::StructureLiteral.new(nil, {
            key_paths.transform => expression.transform
          })
        end

        node = structure
        node.line = self.line

        return node
      end
    }
  end

  rule key_paths
    identifier rest:('.' identifier)* {
      def transform
        ids = []
        ids << identifier.text_value
        
        if rest then
          for i in rest.elements do
            ids << i.identifier.text_value
          end
        end
        
        ("value.s:" + ids.join(".value.s:") + ".value")
      end
    }
  end



  # =========================
  # = Collection Operations =
  # =========================
  
  rule add
    'ADD' s value_expression:expression s 'TO' s container:expression {
      def transform
        value = value_expression.transform
        if value.class == ::Dog::Nodes::Access && value.path.first.kind_of?(String) then
          node = ::Dog::Nodes::Assign.new(
            value.path,
            ::Dog::Nodes::Call.new(
              ::Dog::Nodes::Access.new(["dog", "add:value:to"]), 
              [value, container.transform]
            )
          )
        else
          node = ::Dog::Nodes::Call.new(
            ::Dog::Nodes::Access.new(["dog", "add:value:to"]),
            [value, container.transform]
          )
        end
        
        node.line = self.line
        return node
      end
    }
  end
  
  rule find
    'FIND' s value:expression s 'IN' s container:expression {
      def transform
        node = ::Dog::Nodes::Call.new(
          ::Dog::Nodes::Access.new(["dog", "find_by_id"]),
          [container.transform, value.transform]
        )
        node.line = self.line
        
        return node
      end
    }
    /
    'FIND' s query_expression {
      def transform
        node = ::Dog::Nodes::Call.new(
          ::Dog::Nodes::Access.new(["dog", "find"]),
          [query_expression.transform]
        )
        node.line = self.line
        
        return node
      end
    }
  end
  
  rule remove
    'REMOVE' s query_expression {
      def transform
        node = ::Dog::Nodes::Call.new(
          ::Dog::Nodes::Access.new(["dog", "remove"]),
          [query_expression.transform]
        )
        node.line = self.line
        
        return node
      end
    }
  end
  
  rule update
    'UPDATE' s value:expression s 'IN' s container:expression {
      def transform
        node = ::Dog::Nodes::Call.new(
          ::Dog::Nodes::Access.new(["dog", "update"]),
          [container.transform, value.transform]
        )
        node.line = self.line
        
        return node
      end
    }
  end
  
  rule save
    'SAVE' s value:expression s 'TO' s container:expression {
      def transform
        node = ::Dog::Nodes::Call.new(
          ::Dog::Nodes::Access.new(["dog", "save"]),
          [container.transform, value.transform]
        )
        node.line = self.line
        
        return node
      end
    }
  end
  
  rule delete
    'DELETE' s value:primary_expression s 'FROM' s container:expression {
      def transform
        node = ::Dog::Nodes::Call.new(
          ::Dog::Nodes::Access.new(["dog", "delete"]),
          [container.transform, value.transform]
        )
        node.line = self.line
        
        return node
      end
    }
  end
  
  
  
  # ==============
  # = On Command =
  # ==============
  
  rule on
    'ON' in_clause 'DO' sn statements:(statements)? on_else:(on_else)* s? 'END' {
      def transform
        # TODO - Update for v0.3
        return
      end
    }
  end
  
  rule on_else
    sn? 'ELSE' s 'ON' in_clause 'DO' sn statements:(statements)? {
     def transform
       # TODO - Update for v0.3
     end 
    }
  end
  
  rule on_each
    'ON' sn 'EACH' in_clause 'DO' sn statements:(statements)? s? 'END' {
      def transform
        # TODO - Update for v0.3
        return
      end
    }
  end
  
  
  
  # ===============
  # = Definitions =
  # ===============
  
  rule function_definition
    'DEFINE' s identifier parameters:(s parameter_name s identifier)* s 'DO' sn statements:(statements)? s? 'END' {
      def transform
        name = [identifier.text_value]
        arguments = []

        if !parameters.empty? then
          for p in parameters.elements do
            name << p.parameter_name.text_value.downcase
            arguments << p.identifier.text_value
          end
        end

        if !statements.empty? then
          body = statements.transform
        else
          body = ::Dog::Nodes::Nodes.new([])
        end

        node = ::Dog::Nodes::FunctionDefinition.new(name.join(":"), arguments, body)
        node.line = self.line

        return node
      end
    }
  end

  rule structure_definition
    'DEFINE' s identifier sn? structure_properties {
      def transform
        name = identifier.text_value
        properties = structure_properties.transform
        
        node = ::Dog::Nodes::StructureDefinition.new(name, properties)
        node.line = self.line
        
        return node
      end
    }
  end
  
  rule structure_properties 
    '{' sn? properties:(first:structure_property rest:(((sn? "," sn?)+ / "\n") structure_property)* )? (sn? ','* sn?) '}' {
      def transform
        props = []
        
        if !properties.empty? then
          props = []
          props << properties.first.transform
          
          for r in properties.rest.elements do
            props << r.structure_property.transform
          end
        end
        
        return props
      end
    }
  end
  
  rule structure_property
    sn? association_key value:(s? '=' s? expression)? s? {
      def transform
        property = {}
        
        property["name"] = association_key.transform
        property["default"] = value.expression.transform unless value.empty?
        
        return property
      end
    }
  end
  
  rule value_definition
    'DEFINE' s name:identifier s '=' s literal {
      def transform
        # TODO - Keep in mind that this must be constants that build to a value right now. 
        # I cannot build structures or compute functions
        return 
      end
    }
  end
  
  rule collection_definition
    'DEFINE' s name:identifier s 'OF' s structure_name:packaged_identifier {
      def transform
        value = ::Dog::Value.new("dog.collection", {})
        value["name"] = ::Dog::Value.string_value(name.text_value)
        value["package"] = ::Dog::Value.string_value(self.package)
        
        node = ::Dog::Nodes::Definition.new(name.text_value, value, [], structure_name.transform)
        node.line = self.line
        
        return node
      end
    }
  end
  
  rule community_definition
    'DEFINE' s 'COMMUNITY' s name:identifier s 'USING' s profile_name:identifier sn? structure_properties {
      def transform
        value = ::Dog::Value.new("dog.community", {})
        value["name"] = ::Dog::Value.string_value(name.text_value)
        value["profile"] = ::Dog::Value.string_value(profile_name.text_value)
        value["package"] = ::Dog::Value.string_value(self.package)
        
        profile_definition = ::Dog::Nodes::StructureDefinition.new(profile_name.text_value, structure_properties.transform)
        profile_definition.line = self.line
        
        node = ::Dog::Nodes::Definition.new(name.text_value, value)
        node.line = self.line
        
        nodes = ::Dog::Nodes::Nodes.new([
          node,
          profile_definition
        ])
        nodes.line = self.line
        
        return nodes
      end
    }
  end
  
  
  
  
  # ===================
  # = Others Commands =
  # ===================
  
  rule wait
  'WAIT' s 'ON' s first:expression rest:(s? ',' s? expression)* {
    def transform
      
      expressions = [first.transform]
      
      for e in rest.elements do
        expressions << e.expression.transform
      end
      
      node = ::Dog::Nodes::Wait.new(expressions)
      node.line = self.line
      
      return node
    end
  }
  end
  
  rule spawn
  'SPAWN' s compute {
    def transform
      node = compute.transform
      node.async = true
      
      return node
    end
  }
  end
  
  rule time_construct
    pause / stop / exit
  end
  
  rule pause
    'PAUSE' {
      def transform
        # TODO - Update for v0.3
        return
      end
    }
  end
  
  rule stop
    'STOP' {
      def transform
        # TODO - Update for v0.3
        return
      end
    }
  end
  
  rule exit
    'EXIT' {
      def transform
        # TODO - Update for v0.3
        return
      end
    }
  end
  
  
  rule package 
    'PACKAGE' s identifier {
      def package(call_root = true)
        return identifier.text_value
      end
      
      def transform
        node = ::Dog::Nodes::Package.new(identifier.text_value)
        node.line = self.line
        
        return node
      end
    }
  end
  
  rule perform 
    'PERFORM' s string sn 'RETURN' (sn first:identifier rest:(sn? ',' sn? identifier)*)? {
      def transform
        # TODO - Update for v0.3
        return
      end
    }
  end
  
  rule import
    'IMPORT' s string {
      def transform
        # TODO - Update for v0.3
        return
        
        node = ::Dog::Nodes::Import.new
        node.line = self.line
        node.path = Shellwords::shellwords(string.text_value).first
        return node
      end
    }
  end
  
  rule print
    'PRINT' space expression {
      def transform
        node = ::Dog::Nodes::Call.new(::Dog::Nodes::Access.new(["system", "print:on"]), [expression.transform])
        node.line = self.line
        
        return node
      end
    }
  end
  
  rule inspect
    'INSPECT' space expression {
      def transform
        node = ::Dog::Nodes::Call.new(::Dog::Nodes::Access.new(["system", "inspect:on"]), [expression.transform])
        node.line = self.line
        
        return node
      end
    }
  end
  
  
  
  # ======================
  # = Control Structures =
  # ======================
  
  rule control_structure
    if / for / while / repeat / forever / break / return
  end
  
  rule if
    'IF' s expression s ('THEN' / 'DO') sn statements:(statements)? else_if_clause:(else_if_clause)* else_clause:(else_clause)? s? 'END' {
      def transform
        node = ::Dog::Nodes::Branch.new(expression.transform)
        node.line = self.line
        
        if !statements.empty? then
          node.true_nodes = statements.transform
        end
        
        pointer = node
        
        for clause in else_if_clause.elements
          clause = clause.transform
          
          new_branch = ::Dog::Nodes::Branch.new(clause.first, clause.last)
          new_branch_nodes = ::Dog::Nodes::Nodes.new([
            new_branch
          ])
          
          pointer.false_nodes = new_branch_nodes
          pointer = new_branch
        end
        
        if !else_clause.empty? then
          pointer.false_nodes = else_clause.transform
        end
        
        return node
      end
    }
  end
  
  rule else_if_clause
    sn? 'ELSE' s 'IF' s expression s ('THEN' / 'DO') sn statements:(statements)? {
      def transform
        if !statements.empty? then
          return [expression.transform, statements.transform]
        else
          return [expression.transform, nil]
        end
      end
    } 
  end
  
  rule else_clause
    sn? 'ELSE' sn statements:(statements)? {
      def transform
        if !statements.empty? then
          return statements.transform
        else
          return nil
        end
      end
    }
  end

  rule for
    'FOR' s 'EACH' in_clause 'DO' sn statements:(statements)? s? 'END' {
      def transform
        unique_number = ::Dog::Helper.unique_number
        
        args = in_clause.transform
        
        if !statements.empty? then
          body = statements.transform
        else
          body = ::Dog::Nodes::Nodes.new([])
        end
        
        variable_name = args.first
        source_structure = args.last
        
        keys_variable_name = "@keys_#{unique_number}"
        size_variable_name = "@size_#{unique_number}"
        counter_variable_name = "@counter_#{unique_number}"
        structure_variable_name = "@structure_#{unique_number}"
        
        if source_structure.nil? then
          source_structure = ::Dog::Nodes::Access([::Dog::Language::pluralize(variable_name)])
        end
        
        node = ::Dog::Nodes::Nodes.new([
          ::Dog::Nodes::Assign.new(
            [structure_variable_name],
            source_structure
          ),
          ::Dog::Nodes::Assign.new(
            [keys_variable_name], 
            ::Dog::Nodes::Call.new(
              ::Dog::Nodes::Access.new(["system", "keys"]),
              [::Dog::Nodes::Access.new([structure_variable_name])]
            )
          ),
          ::Dog::Nodes::Assign.new(
            [size_variable_name], 
            ::Dog::Nodes::Call.new(
              ::Dog::Nodes::Access.new(["system", "size"]),
              [::Dog::Nodes::Access.new([keys_variable_name])]
            )
          ),
          Nodes::Assign.new([counter_variable_name], ::Dog::Nodes::NumberLiteral.new(0)),
          ::Dog::Nodes::Loop.new(::Dog::Nodes::Nodes.new([
            ::Dog::Nodes::Branch.new(
              ::Dog::Nodes::Operation.new(
                ::Dog::Nodes::Access.new([counter_variable_name]),
                ::Dog::Nodes::Access.new([size_variable_name]),
                "<"
              ),
              ::Dog::Nodes::Nodes.new([
                ::Dog::Nodes::Nodes.new([
                  ::Dog::Nodes::Assign.new(
                    [variable_name],
                    ::Dog::Nodes::Access.new([
                      structure_variable_name,
                      ::Dog::Nodes::Access.new([
                        keys_variable_name, 
                        ::Dog::Nodes::Access.new([counter_variable_name])
                      ])
                    ])
                  )
                ]),
                ::Dog::Nodes::Assign.new(
                  [counter_variable_name],
                  ::Dog::Nodes::Operation.new(
                    ::Dog::Nodes::Access.new([counter_variable_name]),
                    ::Dog::Nodes::NumberLiteral.new(1),
                    "+"
                  )
                )
              ]), 
              ::Dog::Nodes::Nodes.new([
                ::Dog::Nodes::Break.new
              ])
            ),
            body
          ]))
        ])
        
        node.line = self.line
        
        return node
      end
    }
  end
  
  rule while
    'WHILE' s expression s 'DO' sn statements:(statements)? s? 'END' {
      def transform
        if !statements.empty? then
          body = statements.transform
        else
          body = ::Dog::Nodes::Nodes.new([])
        end
        
        condition = ::Dog::Nodes::Branch.new(
          expression.transform, 
          ::Dog::Nodes::Nodes.new([]),
          ::Dog::Nodes::Nodes.new([
            ::Dog::Nodes::Break.new
          ])
        )
        body.nodes.unshift(condition)
        
        node = ::Dog::Nodes::Loop.new body
        node.line = self.line
        
        return node
      end
    }
  end
  
  rule repeat
    'REPEAT' sn expression sn ('TIMES' / 'DO') sn statements:(statements)? s? 'END' {
      def transform
        unique_number = ::Dog::Helper.unique_number
        counter_variable_name = "@counter_#{unique_number}"
        
        if !statements.empty? then
          body = statements.transform
        else
          body = ::Dog::Nodes::Nodes.new([])
        end
        
        node = ::Dog::Nodes::Nodes.new([
          ::Dog::Nodes::Assign.new([counter_variable_name], ::Dog::Nodes::NumberLiteral.new(0)),
          ::Dog::Nodes::Loop.new(::Dog::Nodes::Nodes.new([
            ::Dog::Nodes::Branch.new(
              ::Dog::Nodes::Operation.new(
                ::Dog::Nodes::Access.new([counter_variable_name]),
                expression.transform,
                "<"
              ),
              ::Dog::Nodes::Nodes.new([
                ::Dog::Nodes::Assign.new(
                  [counter_variable_name],
                  ::Dog::Nodes::Operation.new(
                    ::Dog::Nodes::Access.new([counter_variable_name]),
                    ::Dog::Nodes::NumberLiteral.new(1),
                    "+"
                  )
                )
              ]), 
              ::Dog::Nodes::Nodes.new([
                ::Dog::Nodes::Break.new
              ])
            ),
            body
          ]))
        ])
        
        node.line = self.line
        
        return node
        
        
      end
    }
  end
  
  rule forever
    'FOREVER' sn 'DO' sn statements:(statements)? s? 'END' {
      def transform
        if !statements.empty? then
          body = statements.transform
        else
          body = ::Dog::Nodes::Nodes.new([])
        end
        
        node = ::Dog::Nodes::Loop.new body
        node.line = self.line
        
        return node
      end
    }
  end
  
  rule break
    'BREAK' e:(s expression)? {
      def transform
        exp = nil
        
        if !e.empty? then
          exp = e.expression.transform
        end
        
        node = ::Dog::Nodes::Break.new(exp)
        node.line = self.line
        return node
      end
    }
  end
  
  rule return
    'RETURN' e:(s expression)? {
      def transform
        ret_value = nil
        
        if !e.empty? then
          ret_value = e.expression.transform
        end
        
        node = ::Dog::Nodes::Return.new ret_value
        node.line = self.line
        
        return node
      end
    }
  end
  
  
  
  
  # ==================
  # = Shared Clauses =
  # ==================
  
  rule packaged_identifier
    the_package:(identifier '.')? symbol:identifier {
      def transform
        path = []
        scope = nil
        if !self.the_package.empty? then
          path = [the_package.identifier.text_value, symbol.text_value]
          scope = "external"
        else
          path = [symbol.text_value]
          scope = "internal"
        end
        
        node = ::Dog::Nodes::Access.new(path, scope)
        node.line = self.line
        
        return node
      end
    }
  end
  
  rule via_clause 
    s 'VIA' s identifier {
      def transform
        return ::Dog::Nodes::StringLiteral.new(identifier.text_value)
      end
    }
  end
  
  rule in_clause
    s identifier in_clause_expression:(s 'IN' s expression)? s {
      def transform
        if !in_clause_expression.empty? then
          return [identifier.text_value, in_clause_expression.expression.transform]
        else
          return [identifier.text_value, nil]
        end
      end
    }
  end
  
  
  
  # ================
  # = Dog literals =
  # ================
  
  rule literal
    number / string / bool / null / array / structure
  end
  
  rule array
    '[' sn? items:(first:expression rest:(sn? ',' sn? expression)*)? sn? (',' sn?)? ']' {
      def transform
        type = ::Dog::Nodes::Access.new(["dog", "array"], "external")
        value = {}
        
        if !items.empty? then
          index = 0
          value[0] = self.items.first.transform
          
          if self.items.rest then
            for item in self.items.rest.elements do
              index += 1
              value[index] = item.expression.transform
            end
          end
        end
        
        literal = ::Dog::Nodes::StructureLiteral.new(type, value)
        literal.line = self.line
        
        return literal
      end
    }
  end
  
  rule structure
    type:(packaged_identifier sn?)? '{' sn? associations:(first:association rest:(((sn? "," sn?)+ / "\n")  association)* )? (sn? ','* sn?) '}' {
      def transform
        structure_type = nil
        structure_value = {}
        
        if !type.empty? then
          structure_type = self.type.packaged_identifier.transform
        end
        
        if !associations.empty? then
          a = associations.first.transform
          structure_value[a.first] = a.last
          
          if self.associations.rest then
            for a in self.associations.rest.elements do
              a = a.association.transform
              structure_value[a.first] = a.last
            end
          end
        end
        
        literal = ::Dog::Nodes::StructureLiteral.new(structure_type, structure_value)
        literal.line = self.line
        
        return literal
      end
    }
  end

  rule association
    sn? association_key s? '=' s? expression s? {
      def transform
        return [association_key.transform, expression.transform]
      end
    }
  end
  
  rule association_key
    identifier {
      def transform
        return self.text_value
      end
    }
    / 
    string {
      def transform
        return Shellwords::shellwords(self.text_value).first
      end
    }
    / 
    number {
      def transform
        return self.text_value.to_f
      end
    }
  end
  
  rule string
    (
    '"' ('\"' / !'"' .)* '"'
    /
    '\'' ('\\\'' / !'\'' .)* '\''
    ) {
      def transform
        literal = ::Dog::Nodes::StringLiteral.new Shellwords::shellwords(self.text_value).first
        literal.line = self.line
        
        return literal
      end
    }
  end
  
  rule number
    float / integer
  end
  
  rule integer 
    ('-' s?)? digit+ {
    def transform
      literal = ::Dog::Nodes::NumberLiteral.new self.text_value.to_f
      literal.line = self.line
      
      return literal
    end
    }
  end
  
  rule float
    ('-' s?)? digit+ '.' digit* {
      def transform
        literal = ::Dog::Nodes::NumberLiteral.new self.text_value.to_f
        literal.line = self.line
        
        return literal
      end
    }
  end

  rule bool
    (true / false)
  end

  rule true
    ('TRUE' / 'true') {
      def transform
        node = ::Dog::Nodes::TrueLiteral.new
        node.line = self.line
        return node
      end
    }
  end

  rule false
    ('FALSE' / 'false') {
    def transform
      node = ::Dog::Nodes::FalseLiteral.new
      node.line = self.line
      return node
    end
  }
  end
  
  rule null
    ('NULL' / 'null') {
    def transform
      node = ::Dog::Nodes::NullLiteral.new
      node.line = self.line
      return node
    end
  }
  end
  
  
  
  
  # ===================
  # = Building Blocks =
  # ===================
  
  rule parameter_name
    upper (upper / digit / '_')*
  end

  rule identifier
    lower (lower / digit / '_')*
  end
  
  rule digit
    [0-9]
  end

  rule character
    lower / upper / '_'
  end

  rule lower
    [a-z]
  end

  rule upper
    [A-Z]
  end

  rule t
    terminal
  end

  rule terminal
    (";" / comment / "\n" / end_of_file)
  end

  rule comment
    '#' (!"\n" .)* ("\n" / end_of_file)
  end

  rule sn
    space_newline
  end

  rule space_newline
    (" " / "\t" / "\n" / "\r" / comment)+
  end
  
  rule s
    space
  end

  rule space
    (" " / "\t")+
  end

  rule end_of_file
    !.
  end

end

end
