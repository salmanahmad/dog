#
# Copyright 2011 by Salman Ahmad (salman@salmanahmad.com).
# All rights reserved.
#
# Permission is granted for use, copying, modification, distribution,
# and distribution of modified versions of this work as long as the
# above copyright notice is included.
#

# TODO - '+=' / '-='  / '*=' / '/=' / '%=' / '**=' / '&&=' / '||='

module Dog

grammar Dog

  # ================
  # = Core Program =
  # ================

  rule program
    program_statements <Program>
  end

  rule program_statements
    (top_level_statements / statements) <ProgramStatements>
  end

  rule top_level_statements
    (top_level_statement t)+ <TopLevelStatements>
  end

  rule top_level_statement
    (listen / import / config) <TopLevelStatement>
  end

  rule statements
    ((statement t)+) <Statements>
  end

  rule statement 
    (s? (command / expression / '' ) s?) <Statement>
  end

  rule expression
    (assignment / primary) <Expression>
  end

  rule command
     (on / ask / notify / compute / people / control_structure / print / inspect) <Command>
  end

  # ===============
  # = Expressions =
  # ===============

  rule assignment
    (lhs s '=' s (ask / compute / people)) / (lhs s assignment_operator s primary) <::Dog::Assignment>
  end

  rule primary
    access / operation / literal / identifier / ('(' s? primary s? ')')
  end

  rule operation_first
    (literal / identifier / ('(' s? primary s? ')') / access)
  end

  rule operation
    ((operation_first s binary_operator s (operation / operation_first)) / (unary_operator s primary))
  end

  rule access_first
    (literal / identifier / ('(' s primary s ')') / ('(' s operation s ')'))
  end

  rule access
    (access_first ('.' identifier)+) / (access_first '[ ' primary ']') / (access_first (('\'' / '\'s') s identifier)+)
  end

  rule lhs
    (identifier / access)
  end
  
  rule identifier
    lower (lower / digit / '_')* <::Dog::Identifier>
  end

  rule binary_operator
    (arithmetic_operator / collection_operator / comparative_operator / and_operator / or_operator)
  end
  
  rule unary_operator
    (not_operator)
  end
  
  rule assignment_operator
    '=' <AssignmentOperator>
  end
  
  rule arithmetic_operator
    (addition_operator / subtraction_operator / multiplication_operator / division_operator)
  end
  
  rule comparative_operator
    (equality_operator / inequality_operator / greater_than_operator / less_than_operator / greater_than_equal_operator / less_than_equal_operator)
  end
  
  rule logical_operator
    (and_operator / or_operator / not_operator)
  end
  
  rule collection_operator
    union_operator / append_operator / append_operator / append_operator / prepend_operator
  end
  
  rule addition_operator
    '+' <AdditionOperator>
  end
  
  rule subtraction_operator
    '-' <SubtractionOperator>
  end
  
  rule multiplication_operator
    '*' <MultiplicationOperator>
  end
  
  rule division_operator
    '/' <DivisionOperator>
  end
  
  rule equality_operator
    '==' <EqualityOperator>
  end
  
  rule inequality_operator
    '!=' <InequalityOperator>
  end
  
  rule greater_than_operator
    '>' <GreaterThanOperator>
  end
  
  rule less_than_operator
    '<' <LessThanOperator>
  end
  
  rule greater_than_equal_operator
    '>=' <GreaterThanEqualOperator>
  end
  
  rule less_than_equal_operator
    '<=' <LessThanEqualOperator>
  end
  
  rule and_operator
    'AND' <AndOperator>
  end
  
  rule or_operator
    'OR' <OrOperator>
  end
  
  rule not_operator
    'NOT' <NotOperator>
  end
  
  rule union_operator
    'UNION' <UnionOperator>
  end
  
  rule append_operator
    'INTERSECT' <IntersectOperator>
  end
  
  rule append_operator
    ('DIFFERENCE' / 'DIFF') <DifferenceOperator>
  end
  
  rule append_operator
    'APPEND' <AppendOperator>
  end
  
  rule prepend_operator
    'PREPEND' <PrependOperator>
  end
  
  
  # ==================
  # = Listen Command = 
  # ==================

  rule listen
    ('LISTEN' listen_to_clause listen_for_clause listen_at_clause) <Listen>
  end

  rule listen_to_clause
    (s 'TO' s (people / identifier)) <ListenToClause>
  end

  rule listen_for_clause
    (s 'FOR' s identifier) <ListenForClause>
  end

  rule listen_at_clause
    (s 'AT' s string) <ListenAtClause>
  end



  # ===============
  # = Ask Command =
  # ===============

  rule ask
    ('ASK' sn (integer sn)? (people / identifier) via_clause? sn 'TO' sn ask_function on_clause? (using_clause)? ) <Ask>
  end

  rule ask_function
    (identifier / string)
  end



  # ==========
  # = Notify =
  # ==========

  rule notify
    ('NOTIFY' s (identifier / people) via_clause? notify_of_clause using_clause?) <Notify>
  end

  rule notify_of_clause
    (s 'OF' s (identifier / string)) <NotifyOfClause>
  end



  # ===================
  # = Compute Command =
  # ===================

  rule compute
    ('COMPUTE' s identifier on_clause? using_clause? ) <Compute>
  end



  # ==================
  # = Shared Clauses =
  # ==================

  rule using_clause
    (s 'USING' s (parameters / assignment_list / identifier)) <UsingClause>
  end

  rule on_clause 
    (s ('ON' s)? primary) <OnClause>
  end

  rule via_clause 
    (s 'VIA' s ('email' / 'im' / 'sms')) <ViaClause>
  end

  rule in_clause
    (s ((identifier s 'IN' s primary) / identifier) s) <InClause>
  end



  # ==================
  # = People Command =
  # ==================

  rule users
    (me / public / people) <User>
  end

  rule me
    ('ME') <Me>
  end

  rule public
    ('PUBLIC') <Public>
  end

  rule people
    (('PEOPLE' / 'PERSON') people_from_clause (people_where_clause)? ) <People>
  end

  rule people_from_clause
    (sn 'FROM' sn (community_list / primary)) <PeopleFromClause>
  end

  rule people_where_clause
    (sn 'WHERE' sn predicate) <PeopleWhereClause>
  end
  
  rule predicate
    (predicate_boolean / predicate_primary)
  end 
  
  rule predicate_boolean 
    (predicate_and / predicate_or / predicate_not)
  end 
  
  rule predicate_or 
    (predicate_primary s "OR" s predicate)
  end 

  rule predicate_and
    (predicate_primary s "AND" s predicate)
  end 
  
  rule predicate_not
    ('NOT' s predicate)
  end
  
  rule predicate_primary 
    conditional / parenthesis_predicate
  end 
  
  rule parenthesis_predicate 
    ('(' space predicate space ')')
  end
  
  rule conditional
    (key_path s conditional_operator s primary)
  end
  
  rule conditional_operator
    (">" / "<" / "<=" / ">=" / "==" / "!=" / "ASSOCIATES" / "CONTAINS" / "STARTSWITH" / "ENDSWITH")
  end
  
  rule key_path
    identifier ('.' identifier)*
  end



  # ==============
  # = On Command =
  # ==============

  rule on
    ('ON' in_clause 'DO' sn statements sn? 'END') <OnBlock>
  end



  # ===================
  # = Others Commands =
  # ===================
  
  rule config
    'CONFIG' s identifier s '=' s literal <::Dog::Config>
  end
  
  rule import 
    'IMPORT' s type:(import_function / import_data / import_community / import_task / import_message / import_config) s string (s 'AS' s identifier)? <::Dog::Import>
  end
  
  rule import_function
    'FUNCTION' <::Dog::ImportFunction>
  end
  
  rule import_data
    'DATA' <::Dog::ImportData>
  end
  
  rule import_community
    'COMMUNITY' <::Dog::ImportCommunity>
  end
  
  rule import_task
    'TASK' <::Dog::ImportTask>
  end
  
  rule import_message
    'MESSAGE' <::Dog::ImportMessage>
  end
  
  rule import_config
    'CONFIG' <::Dog::ImportConfig>
  end
  
  rule parameters
    ('PARAMETERS' space_newline ('WITH' space_newline assignment_list)? ) <Parameters>
  end
  
  rule print
    ('PRINT' space primary) <Print>
  end
  
  rule inspect
    ('INSPECT' space primary) <Inspect>
  end



  # =========
  # = Lists =
  # =========

  rule community_list
    (string (sn 'AND' sn string)*)
  end

  rule assignment_list
    (assignment_list_assignment sn ((',' / 'AND') sn assignment_list_assignment)*)
  end

  rule assignment_list_assignment
    (identifier s '=' s primary)
  end



  # ======================
  # = Control Structures =
  # ======================

  rule control_structure
    (if / for)
  end

  rule if
    ('IF' s primary (s 'THEN')? sn statements sn 'END') <If>
  end

  rule for
    ('FOR' s 'EACH' in_clause 'DO' sn statements sn? ('END' / ('UNTIL' s primary))) <For>
  end



  # ================
  # = Dog literals =
  # ================

  rule literal
    (number / string / bool / collection)
  end

  rule collection
    (array / hash)
  end

  rule array 
    '[' items? ']' <::Dog::ArrayLiteral>
  end

  rule items
    item+ <::Dog::ArrayItems>
  end
  
  rule item
    sn? primary sn? ','? <::Dog::ArrayItem>
  end
  
  rule hash 
    '{' associations? '}' <::Dog::HashLiteral>
  end

  rule associations
    association+ <::Dog::HashAssociations>
  end

  rule association 
    sn? key:string s? ':' s? value:primary sn? ','? <::Dog::HashAssociation>
  end

  rule bool
    (true / false)
  end

  rule true
    (
      'TRUE' <::Dog::TrueLiteral>
      / 
      'true' <::Dog::TrueLiteral>
      /
      'YES' <::Dog::TrueLiteral>
      /
      'yes' <::Dog::TrueLiteral>
    ) 
  end

  rule false
    (
      'FALSE' <::Dog::FalseLiteral>
      / 
      'false' <::Dog::FalseLiteral>
      / 
      'NO' <::Dog::FalseLiteral>
      / 
      'no' <::Dog::FalseLiteral>
    ) 
  end

  rule number
    float / integer
  end

  rule integer 
    ('-' s?)? digit+ <::Dog::IntegerLiteral>
  end

  rule float
    ('-' s?)? digit+ '.' digit* <::Dog::FloatLiteral>
  end

  rule string
    (
    '"' ('\"' / !'"' .)* '"' <::Dog::StringLiteral>
    /
    '\'' ('\\\'' / !'\'' .)* '\'' <::Dog::StringLiteral>
    )
  end

  rule digit
    [0-9]
  end

  rule character
    lower / upper / '_'
  end

  rule lower
    [a-z]
  end

  rule upper
    [A-Z]
  end

  rule t
    terminal
  end

  rule terminal
    (";" / "\n" / end_of_file)
  end

  rule sn
    space_newline
  end

  rule space_newline
    [ \t\n\r]+
  end

  rule s
    space
  end

  rule space
    [ \t]+
  end
  
  rule end_of_file
    !.
  end

end

end
