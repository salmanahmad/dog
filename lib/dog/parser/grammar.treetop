#
# Copyright 2011 by Salman Ahmad (salman@salmanahmad.com).
# All rights reserved.
#
# Permission is granted for use, copying, modification, distribution,
# and distribution of modified versions of this work as long as the
# above copyright notice is included.
#

module Dog

grammar Dog

  # ================
  # = Core Program =
  # ================

  rule program
    statements
    / 
    ''
  end
  
  rule statements
    statement+ {
      def transform
        nodes = ::Dog::Nodes::Nodes.new []
        nodes.line = self.line
        
        nodes.nodes = []
        
        if elements then
          for element in elements do
            element = element.transform
            nodes.nodes << element if element
          end
        end
        
        return nodes
      end  
    }
  end
  
  # TODO - Perhaps add assignments to expressions. In ruby you can 
  # technically do stuff like this: j = (i = 5) and j = i = 5
  # Also, by combining them, we can add inline conditionals like:
  # i = 5 if true and i = 5 unless true. Right now, we can only attach
  # inline conditionals to statements, not expressions which means we can
  # only have one per "line"
  
  rule statement
    s? expression s? t {
      def transform
        return self.expression.transform
      end
    }
    /
    s t
    / 
    "\n"
    /
    ";"
    /
    comment
  end
  
  
  
  # ===============
  # = Expressions =
  # ===============
  
  rule expression
    assignment_expression
  end
  
  rule assignment_expression
    assignment
    /
    match_expression
  end
  
  rule match_expression
    left:(or_expression) s? match_operator s? right:(or_expression) {
      def transform
        node = ::Dog::Nodes::Operation.new(left.transform, right.transform, match_operator.transform)
        node.line = self.line
        
        return node
      end
    }
    /
    or_expression
  end
  
  rule or_expression
    and_expression s or_operator s or_expression {
      def transform
        node = ::Dog::Nodes::Operation.new(and_expression.transform, or_expression.transform, or_operator.transform)
        node.line = self.line
        
        return node
      end
    }
    /
    and_expression
  end
  
  rule and_expression
    relational_expression s and_operator s and_expression {
      def transform
        node = ::Dog::Nodes::Operation.new(relational_expression.transform, and_expression.transform, and_operator.transform)
        node.line = self.line
        
        return node
      end
    }
    /
    relational_expression
  end
  
  rule relational_expression
    additive_expression s? relational_operator s? relational_expression {
      def transform
        node = ::Dog::Nodes::Operation.new(additive_expression.transform, relational_expression.transform, relational_operator.transform)
        node.line = self.line
        
        return node
      end
    }
    /
    additive_expression
  end
  
  rule additive_expression
    multiplicative_expression s? additive_operator s? additive_expression {
      def transform
        node = ::Dog::Nodes::Operation.new(multiplicative_expression.transform, additive_expression.transform, additive_operator.transform)
        node.line = self.line
        
        return node
      end
    }
    /
    multiplicative_expression
  end
  
  rule multiplicative_expression
    unary_expression s? multiplicative_operator s? multiplicative_expression {
      def transform
        node = ::Dog::Nodes::Operation.new(unary_expression.transform, multiplicative_expression.transform, multiplicative_operator.transform)
        node.line = self.line
        
        return node
      end
    }
    /
    unary_expression
  end
  
  rule unary_expression
    unary_operator s unary_expression {
      def transform
        node = ::Dog::Nodes::Operation.new(unary_expression.transform, nil, unary_operator.transform)
        node.line = self.line
        
        return node
      end
    }
    /
    query_expression
  end
  
  rule query_expression
    primary_expression s predicate {
      def transform
        node = ::Dog::Nodes::StructureLiteral.new(::Dog::Nodes::Access.new(["dog", "query"]), {
          "object" => primary_expression.transform,
          "predicate" => predicate.transform
        })
        node.line = self.line
        
        return node
      end
    }
    /
    primary_expression
  end
  
  rule primary_expression
    access
    /
    compute
    /
    ask
    /
    listen
    /
    notify
    /
    function_definition
    /
    structure_definition
    /
    collection_definition
    /
    community_definition
    /
    control_structure
    /
    perform
    /
    import
    /
    package
    /
    print
    /
    inspect
    /
    on
    /
    user
    /
    predicate
  end
  
  # TODO - Remove this. I am keeping it around for documentaiton purposes
  # Mostly I am keep it around so that I can remember:
  #    reply
  #    config
  
  
  # ==============
  # = Assignment =
  # ==============
  
  rule assignment
    scope:(scope:('external' / 'internal' / 'local') s)? assignment_access s? assignment_operator s? expression {
      def transform
        node = ::Dog::Nodes::Assign.new(assignment_access.transform, expression.transform)
        node.line = self.line
        
        if !self.scope.empty? then
          node.scope = self.scope.scope.text_value
        end
        
        return node
      end
    }
  end
  
  rule assignment_access
    identifier access_tail:(access_tail)? {
      def transform
        if !access_tail.empty? then
          return access_tail.transform.clone.unshift(identifier.text_value)
        else
          return [identifier.text_value]
        end
      end
    }
  end
  
  rule access
    scope:(scope:('external' / 'internal' / 'local') s)? access_head access_tail:(access_tail)? {
      def transform
        if !access_tail.empty? then
          path = access_tail.transform.clone.unshift(access_head.transform)
        else
          path = [access_head.transform]
        end
        
        node = ::Dog::Nodes::Access.new(path)
        node.line = self.line
        
        if !self.scope.empty? then
          node.scope = self.scope.scope.text_value
        end
        
        return node
      end
    }
  end
  
  rule access_head
    literal
    /
    identifier {
      def transform
        return self.text_value
      end
    }
    / 
    '(' sn? expression sn? ')' {
      def transform
        return expression.transform
      end
    }
  end
  
  rule access_tail
    access_dot
    / 
    access_bracket
  end
  
  rule access_dot
    '.' identifier access_tail:(access_tail)? {
      def transform
        if !access_tail.empty? then
          return access_tail.transform.clone.unshift(identifier.text_value)
        else
          return [identifier.text_value]
        end
      end
    }
  end
  
  rule access_bracket
    '[' s? expression s? ']' access_tail:(access_tail)? {
      def transform
        if !access_tail.empty? then
          return access_tail.transform.clone.unshift(expression.transform)
        else
          return [expression.transform]
        end
      end
    }
  end
  
  
  
  # =============
  # = Operators =
  # =============
  
  rule assignment_operator
    '=' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule relational_operator
    equality_operator
    / 
    inequality_operator
    / 
    greater_than_equal_operator
    / 
    less_than_equal_operator
    / 
    greater_than_operator
    / 
    less_than_operator
  end
  
  rule additive_operator
    addition_operator 
    / 
    subtraction_operator
  end
  
  rule multiplicative_operator
    multiplication_operator 
    / 
    division_operator
  end
  
  rule unary_operator
    not_operator
  end
  
  rule addition_operator
    '+' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule subtraction_operator
    '-' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule multiplication_operator
    '*' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule division_operator
    '/' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule equality_operator
    '==' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule inequality_operator
    '!=' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule greater_than_operator
    '>' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule less_than_operator
    '<' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule greater_than_equal_operator
    '>=' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule less_than_equal_operator
    '<=' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule and_operator
    'AND' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule or_operator
    'OR' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule not_operator
    'NOT' {
      def transform
        return self.text_value
      end
    }
  end
  
  rule match_operator
    '?' {
      def transform
        return self.text_value
      end
    }
  end
  
  
  # ===================
  # = Compute Command =
  # ===================
  
  rule compute
    'COMPUTE' s packaged_identifier on_clause:(on_clause)? using_clause:(using_clause)? {
      def transform
        function = packaged_identifier.transform
        mandatory_arguments = on_clause.transform unless on_clause.empty?
        optional_arguments = using_clause.transform unless using_clause.empty?
        
        node = ::Dog::Nodes::Call.new(
          function,
          mandatory_arguments,
          optional_arguments
        )
        node.line = self.line
        
        return node
      end
    }
  end
  
  
  
  # ===============
  # = Ask Command =
  # ===============
  
  rule ask
    'ASK' sn ask_count? expression via_clause:(via_clause)? ask_to_clause on_clause:(on_clause)? using_clause:(using_clause)? {
      def transform
        # TODO - Handle VIA
        # TODO - Handle AskCount
        actor = expression.transform
        via = via_clause.transform
        function = ask_to_clause.transform
        mandatory_arguments = on_clause.transform unless on_clause.empty?
        optional_arguments = using_clause.transform unless using_clause.empty?
        
        node = ::Dog::Nodes::AsyncCall.new(
          actor,
          function,
          mandatory_arguments,
          optional_arguments
        )
        node.line = self.line
        
        return node
      end
    }
  end
  
  # TODO - Actually use this information
  rule ask_count
    integer sn {
      def transform
        return integer.text_value.to_f
      end
    }
  end
  
  # TODO - Bring back - also for compute
  #s 'TO' s (string / access)
  rule ask_to_clause
    s 'TO' s packaged_identifier {
      def transform
        return packaged_identifier.transform
      end
    }
  end
  
  
  
  # ==================
  # = Listen Command = 
  # ==================
  
  rule listen
    'LISTEN' listen_to_clause via_clause:(via_clause)? listen_for_clause {
      def transform
        query = listen_to_clause.transform
        for_clause = listen_for_clause.transform
        
        if via_clause.empty?
          via = ::Dog::Nodes::NullLiteral.new
        else
          via = via_clause.transform
        end
        
        variable_name = for_clause.first
        type = for_clause.last
        
        if type.nil? then
          string_value = ::Dog::Value.new("type", {})
          string_value["name"] = ::Dog::Value.string_value("string")
          string_value["package"] = ::Dog::Value.string_value("system")
          string_value = ::Dog::Nodes::ValueLiteral.new(string_value)
          structure_value = ::Dog::Nodes::Access.new([::Dog::Language::singularize(variable_name)])
          type = ::Dog::Nodes::Branch.new(
            ::Dog::Nodes::Operation.new(
              structure_value,
              ::Dog::Nodes::NullLiteral.new,
              "=="
            ),
            ::Dog::Nodes::Nodes.new([
              string_value
            ]),
            ::Dog::Nodes::Nodes.new([
              structure_value
            ])
          )
        end
        
        node = ::Dog::Nodes::Assign.new(
          [variable_name],
          ::Dog::Nodes::Call.new(
            ::Dog::Nodes::Access.new(["dog", "listen"]),
            [type, query, via]
          )
        )
        node.line = self.line
        
        return node
      end
    }
  end

  rule listen_to_clause
    s 'TO' s expression {
      def transform
        return expression.transform
      end
    }
  end
  
  rule listen_for_clause
    s 'FOR' s identifier listen_of_clause:(listen_of_clause)? {
      def transform
        if !listen_of_clause.empty?
          return [identifier.text_value, listen_of_clause.transform]
        else
          return [identifier.text_value, nil]
        end
      end
    }
  end
  
  rule listen_of_clause
    s 'OF' s packaged_identifier {
      def transform
        return packaged_identifier.transform
      end
    }
  end
  
  
  
  # ==========
  # = Notify =
  # ==========
  
  rule notify
    'NOTIFY' s expression via_clause notify_of_clause {
      def transform
        node = ::Dog::Nodes::Call.new(
          ::Dog::Nodes::Access.new(["dog", "notify"]),
          [notify_of_clause.transform, expression.transform, via_clause.transform]
        )
        node.line = self.line
        
        return node
      end
    }
  end
  
  rule notify_of_clause
    s 'OF' s expression {
      def transform
        return expression.transform
      end
    }
  end
  
  
  
  
  # ==================================
  # = Predicates and Queries Command =
  # ==================================
  
  # FIXME
  
  rule user
    me / public / people / person
  end
  
  rule me
    'ME'
  end
  
  rule public
    'PUBLIC'
  end
  
  rule person
    'PERSON' people_from_clause? (people_where_clause)?
  end
  
  rule people
    'PEOPLE' people_from_clause? (people_where_clause)?
  end
  
  # TODO - Add back community list. Right now, you can only access people from 
  # one community at a time...
  rule people_from_clause
    sn 'FROM' sn access
  end

  rule people_where_clause
    sn 'WHERE' sn predicate_expression
  end
  
  rule predicate
    'WHERE' sn predicate_expression {
      def transform
        predicate_expression.transform
      end
    }
  end
  
  rule predicate_expression
    predicate_unary
    /
    predicate_binary
    /
    predicate_primary
  end 
  
  rule predicate_unary
    not_operator s? '(' s? predicate_primary s? ')'
  end
  
  rule predicate_binary
    predicate_primary s (and_operator / or_operator) s predicate_expression
  end
  
  rule predicate_primary 
    predicate_parenthesis / predicate_conditional
  end 
  
  rule predicate_parenthesis 
    '(' s? predicate_expression s? ')'
  end
  
  # This was 'access' before 'expression'
  rule predicate_conditional
    key_paths s? relational_operator s? expression {
      def transform
        {key_paths.transform => expression.transform}
      end
    }
  end
  
  
  
  
  
  # ==============
  # = On Command =
  # ==============
  
  rule on
    'ON' on_each in_clause 'DO' sn statements:(statements)? s? 'END' {
      def transform
        args = in_clause.transform
        body = statements.transform unless statements.empty?
        
        variable_name = args.first
        source_structure = args.last
        
        if source_structure.nil? then
          source_structure = ::Dog::Nodes::Access.new([::Dog::Language::pluralize(variable_name)])
        end
        
        # TODO - Detect duplicated ON EACH names somehow
        # TODO - Handle nested ON EACH stuffs
        function_name = "@each:#{variable_name}"
        function_target = nil
        function_mandatory_arguments = [variable_name]
        function_optional_arguments = nil
        function_body = body
        
        node = ::Dog::Nodes::FunctionDefinition.new(function_name, function_body, function_mandatory_arguments, function_optional_arguments)
        node.line = self.line
        
        type = ::Dog::Value.new("type", {})
        type["name"] = ::Dog::Value.string_value(function_name)
        type["package"] = ::Dog::Value.string_value(self.package)
        
        # TODO - This is another example of when I would want to have access to the package name
        register = ::Dog::Nodes::Call.new(
          ::Dog::Nodes::Access.new(["dog", "register_handler"]),
          [source_structure, ::Dog::Nodes::ValueLiteral.new(type)]
        )
        register.line = self.line
        
        nodes = ::Dog::Nodes::Nodes.new([
          node,
          register
        ])
        nodes.line = self.line
        
        return nodes
      end
    }
  end
  
  rule on_each
    s 'EACH' on_each_count:(s integer)? {
      def transform
        # TODO - Support the count variable
        if !on_each_count.empty? then
          return on_each_count.integer.to_f
        else
          return 1
        end
      end
    }
  end
  
  
  
  # ===============
  # = Definitions =
  # ===============
  
  # TODO - This is a huge problem - I need to add type annotations to the function declaration and implement the multiple dispatch
  
  rule function_definition
  # TODO - How do I handle nested function names?
    'DEFINE' s identifier function_for:(function_for)? function_on:(function_on)? function_using:(function_using)? s 'DO' sn statements:(statements)? s? 'END' {
      def transform
        # TODO - Handle nested function definitions
        
        actor = function_for.transform unless function_for.empty?

        function_name = identifier.text_value
        function_mandatory_arguments = function_on.transform unless function_on.empty?
        function_optional_arguments = function_using.transform unless function_using.empty?

        if actor then
          instructions = nil
          output = nil

          if !statements.empty? then
            instructions = statements.external_instructions
            output = statements.external_output
          end

          node = ::Dog::Nodes::ExternalFunctionDefinition.new(function_name, actor, instructions, function_mandatory_arguments, function_optional_arguments, output)
          node.line = self.line

          return node
        else
          function_body = statements.transform unless statements.empty?

          node = ::Dog::Nodes::FunctionDefinition.new(function_name, function_body, function_mandatory_arguments, function_optional_arguments)
          node.line = self.line

          return node
        end
      end
    }
  end
  
  rule function_for
    s 'FOR' s identifier {
      def transform
        return identifier.text_value
      end
    }
  end
  
  rule function_on
    s 'ON' s first:identifier rest:(s? ',' s? identifier)* {
      def transform
        args = []
        
        args << first.text_value
        
        for r in rest.elements do
          args << r.identifier.text_value
        end
        
        return args
      end
    }
  end
  
  rule function_using
    s 'USING' s function_using_parameter rest:(s? ',' s? function_using_parameter)* {
      def transform
        args = {}
        
        parameter = function_using_parameter.transform
        args[parameter.first] = parameter.last
        
        for r in rest.elements do
          parameter = r.function_using_parameter.transform
          args[parameter.first] = parameter.last
        end
        
        return args
      end
    }
  end
  
  rule function_using_parameter
    identifier s? '=' s? expression {
      def transform
        return [identifier.text_value, expression.transform]
      end
    }
  end
  
  rule structure_definition
    'DEFINE' s identifier sn? structure_properties {
      def transform
        name = identifier.text_value
        properties = structure_properties.transform
        
        node = ::Dog::Nodes::StructureDefinition.new(name, properties)
        node.line = self.line
        
        return node
      end
    }
  end
  
  rule structure_properties 
    '{' sn? properties:(first:structure_property rest:(((sn? "," sn?)+ / "\n") structure_property)* )? sn? '}' {
      def transform
        props = []
        
        if !properties.empty? then
          props = []
          props << properties.first.transform
          
          for r in properties.rest.elements do
            props << r.structure_property.transform
          end
        end
        
        return props
      end
    }
  end
  
  rule structure_property
    sn? type:(identifier s) structure_property_key value:(s? '=' s? expression)? s? {
      def transform
        property = {}
        
        property["type"] = type.identifier.text_value unless type.empty?
        property["name"] = structure_property_key.transform
        property["default"] = value.expression.transform unless value.empty?
        
        return property
      end
    }
    /
    sn? structure_property_key value:(s? '=' s? expression)? s? {
      def transform
        property = {}
        
        property["name"] = structure_property_key.transform
        property["default"] = value.expression.transform unless value.empty?
        
        return property
      end
    }
  end
  
  rule structure_property_key
    identifier {
      def transform
        return self.text_value
      end
    }
    / 
    string {
      def transform
        return Shellwords::shellwords(self.text_value).first
      end
    }
    / 
    number {
      def transform
        return self.text_value.to_f
      end
    }
  end
  
  rule collection_definition
    'DEFINE' s name:identifier s 'OF' s structure_name:packaged_identifier {
      def transform
        value = ::Dog::Value.new("collection", {})
        value["name"] = ::Dog::Value.string_value(name.text_value)
        value["package"] = ::Dog::Value.string_value(self.package)
        
        node = ::Dog::Nodes::Definition.new(name.text_value, value, structure_name.transform)
        node.line = self.line
        
        return node
      end
    }
  end
  
  rule community_definition
    'DEFINE' s 'COMMUNITY' s name:identifier s 'USING' s profile_name:identifier sn? structure_properties {
      def transform
        node = ::Dog::Nodes::CommunityDefinition.new(name.text_value, profile_name.text_value, structure_properties.transform)
        node.line = self.line
        
        return node
      end
    }
  end
  
  
  
  
  # ===================
  # = Others Commands =
  # ===================
  
  rule package 
    'PACKAGE' s identifier {
      def package(call_root = true)
        return identifier.text_value
      end
      
      def transform
        node = ::Dog::Nodes::Package.new(identifier.text_value)
        node.line = self.line
        
        return node
      end
    }
  end
  
  rule perform 
    'PERFORM' s string {
      def external_instructions
        # Return a ruby string object, not a Dog string literal
        return string.transform.value
      end
      
      def transform
        raise "Parser error: perform must only be present in an external function definition."
      end
    }
  end
  
  # TODO
  rule import
  # FIXME - Change to include
    'IMPORT' s string {
      def transform
        node = ::Dog::Nodes::Import.new
        node.line = self.line
        node.path = Shellwords::shellwords(string.text_value).first
        return node
      end
    }
  end
  
  rule print
    'PRINT' space expression {
      def transform
        node = ::Dog::Nodes::Call.new(::Dog::Nodes::Access.new(["system", "print"]), [expression.transform])
        node.line = self.line
        
        return node
      end
    }
  end
  
  rule inspect
    'INSPECT' space expression {
      def transform
        node = ::Dog::Nodes::Call.new(::Dog::Nodes::Access.new(["system", "print"]), [expression.transform])
        node.line = self.line
        
        return node
      end
    }
  end
  
  
  
  # ======================
  # = Control Structures =
  # ======================
  
  rule control_structure
    if / for / while / break / return
  end
  
  rule if
    'IF' s expression s 'THEN' sn statements:(statements)? else_if_clause:(else_if_clause)* else_clause:(else_clause)? s? 'END' {
      def transform
        node = ::Dog::Nodes::Branch.new(expression.transform)
        node.line = self.line
        
        if !statements.empty? then
          node.true_nodes = statements.transform
        end
        
        pointer = node
        
        for clause in else_if_clause.elements
          clause = clause.transform
          
          new_branch = ::Dog::Nodes::Branch.new(clause.first, clause.last)
          new_branch_nodes = ::Dog::Nodes::Nodes.new([
            new_branch
          ])
          
          pointer.false_nodes = new_branch_nodes
          pointer = new_branch
        end
        
        if !else_clause.empty? then
          pointer.false_nodes = else_clause.transform
        end
        
        return node
      end
    }
  end
  
  rule else_if_clause
    sn? 'ELSE' s 'IF' s expression s 'THEN' sn statements:(statements)? {
      def transform
        if !statements.empty? then
          return [expression.transform, statements.transform]
        else
          return [expression.transform, nil]
        end
      end
    } 
  end
  
  rule else_clause
    sn? 'ELSE' sn statements:(statements)? {
      def transform
        if !statements.empty? then
          return statements.transform
        else
          return nil
        end
      end
    }
  end

  rule for
    'FOR' s 'EACH' in_clause 'DO' sn statements:(statements)? s? 'END' {
      def transform
        unique_number = ::Dog::Helper.unique_number
        
        args = in_clause.transform
        
        if !statements.empty? then
          body = statements.transform
        else
          body = ::Dog::Nodes::Nodes.new([])
        end
        
        variable_name = args.first
        source_structure = args.last
        
        keys_variable_name = "@keys_#{unique_number}"
        size_variable_name = "@size_#{unique_number}"
        counter_variable_name = "@counter_#{unique_number}"
        structure_variable_name = "@structure_#{unique_number}"
        
        if source_structure.nil? then
          source_structure = ::Dog::Nodes::Access([::Dog::Language::pluralize(variable_name)])
        end
        
        node = ::Dog::Nodes::Nodes.new([
          ::Dog::Nodes::Assign.new(
            [structure_variable_name],
            source_structure
          ),
          ::Dog::Nodes::Assign.new(
            [keys_variable_name], 
            ::Dog::Nodes::Call.new(
              ::Dog::Nodes::Access.new(["system", "keys"]),
              [::Dog::Nodes::Access.new([structure_variable_name])]
            )
          ),
          ::Dog::Nodes::Assign.new(
            [size_variable_name], 
            ::Dog::Nodes::Call.new(
              ::Dog::Nodes::Access.new(["system", "size"]),
              [::Dog::Nodes::Access.new([keys_variable_name])]
            )
          ),
          Nodes::Assign.new([counter_variable_name], ::Dog::Nodes::NumberLiteral.new(0)),
          ::Dog::Nodes::Loop.new([
            ::Dog::Nodes::Branch.new(
              ::Dog::Nodes::Operation.new(
                ::Dog::Nodes::Access.new([counter_variable_name]),
                ::Dog::Nodes::Access.new([size_variable_name]),
                "<"
              ),
              ::Dog::Nodes::Nodes.new([
                ::Dog::Nodes::Nodes.new([
                  ::Dog::Nodes::Assign.new(
                    [variable_name],
                    ::Dog::Nodes::Access.new([
                      structure_variable_name,
                      ::Dog::Nodes::Access.new([
                        keys_variable_name, 
                        ::Dog::Nodes::Access.new([counter_variable_name])
                      ])
                    ])
                  )
                ]),
                ::Dog::Nodes::Assign.new(
                  [counter_variable_name],
                  ::Dog::Nodes::Operation.new(
                    ::Dog::Nodes::Access.new([counter_variable_name]),
                    ::Dog::Nodes::NumberLiteral.new(1),
                    "+"
                  )
                )
              ]), 
              ::Dog::Nodes::Nodes.new([
                ::Dog::Nodes::Break.new
              ])
            ),
            body
          ])
        ])
        
        node.line = self.line
        
        return node
      end
    }
  end
  
  rule while
    'WHILE' s expression s 'DO' sn statements:(statements)? s? 'END' {
      def transform
        if !statements.empty? then
          body = statements.transform
        else
          body = ::Dog::Nodes::Nodes.new([])
        end
        
        condition = ::Dog::Nodes::Branch.new(
          expression.transform, 
          ::Dog::Nodes::Nodes.new([]),
          ::Dog::Nodes::Nodes.new([
            ::Dog::Nodes::Break.new
          ])
        )
        body.nodes.unshift(condition)
        
        node = ::Dog::Nodes::Loop.new body
        node.line = self.line
        
        return node
      end
    }
  end
  
  rule break
    'BREAK' e:(s expression)? {
      def transform
        exp = nil
        
        if !e.empty? then
          exp = e.expression.transform
        end
        
        node = ::Dog::Nodes::Break.new(exp)
        node.line = self.line
        return node
      end
    }
  end
  
  rule return
    'RETURN' expressions:(s first:expression rest:(s? ',' s? expression)*)? {
      def external_output
        # TODO - I am duplicating this for now until I add proper multiple returns.
        # See the transform method for additional context. Down the road I should just
        # call self.transform directly
        
        output = []
        es = []
        if !self.expressions.empty? then
          es << self.expressions.first.transform
          
          for r in self.expressions.rest.elements do
            es << r.expression.transform
          end
        end
        
        for e in es do
          if e.class == ::Dog::Nodes::Access && e.path.size == 1 then
            output << e.path.first
          else
            raise "Parser error: return statements in external functions can only return expressions"
          end
        end
        
        return output
      end
      
      def transform
        # TODO - Handle multiple return values - Build a structure and just return that?
        
        es = []
        if !self.expressions.empty? then
          es << self.expressions.first.transform
          
          for r in self.expressions.rest.elements do
            es << r.expression.transform
          end
        end
        
        node = ::Dog::Nodes::Return.new es.first
        node.line = self.line
        
        return node
      end
    }
  end
  
  
  
  
  # ==================
  # = Shared Clauses =
  # ==================
  
  rule packaged_identifier
    the_package:(identifier '.')? symbol:identifier {
      def transform
        path = []
        scope = nil
        if !self.the_package.empty? then
          path = [the_package.identifier.text_value, symbol.text_value]
          scope = "external"
        else
          path = [symbol.text_value]
        end
        
        node = ::Dog::Nodes::Access.new(path)
        node.line = self.line
        node.scope = scope
        
        return node
      end
    }
  end
  
  rule using_clause
    s 'USING' s first:(identifier s? '=' s? expression) rest:(s? ',' s? identifier s? '=' s? expression)* {
      def transform
        args = {}
        
        args[first.identifier.text_value] = first.expression.transform
        
        for r in rest.elements do
          args[r.identifier.text_value] = r.expression.transform
        end
        
        node = ::Dog::Nodes::StructureLiteral.new(nil, args)
        node.line = self.line
        
        return node
      end
    }
  end
  
  rule on_clause
  s 'ON' s first:expression rest:(s? ',' s? expression)* {
    def transform
      args = []
      
      args << first.transform
      
      for r in rest.elements do
        args << r.expression.transform
      end
      
      return args
    end
  }
  /
  s 'ON' s first:(identifier s? '=' s? expression) rest:(s? ',' s? identifier s? '=' s? expression)* {
    def transform
      args = {}
      
      args[first.identifier.text_value] = first.expression.transform
      
      for r in rest.elements do
        args[r.identifier.text_value] = r.expression.transform
      end
      
      return args
    end
  }
  end
  
  rule via_clause 
    s 'VIA' s identifier {
      def transform
        return ::Dog::Nodes::StringLiteral.new(identifier.text_value)
      end
    }
  end
  
  rule in_clause
    s identifier in_clause_expression:(s 'IN' s expression)? s {
      def transform
        if !in_clause_expression.empty? then
          return [identifier.text_value, in_clause_expression.expression.transform]
        else
          return [identifier.text_value, nil]
        end
      end
    }
  end
  
  
  
  # =========
  # = Lists =
  # =========
  
  rule key_paths
    identifier rest:('.' identifier)* {
      def transform
        ids = []
        ids << identifier.text_value
        
        if rest then
          for i in rest.elements do
            ids << i.identifier.text_value
          end
        end
        
        ids.join(".")
      end
    }
  end
  
  
  
  # ================
  # = Dog literals =
  # ================
  
  rule literal
    number / string / bool / null / structure
  end
  
  # TODO - I am keep this for the future if I choose to include this syntactic sugar
  #rule array 
  #  '[' sn? items? sn? (',' sn?)? ']' <::Dog::Nodes::ArrayLiteral>
  #end
  #
  #rule items
  #  item+ <::Dog::Nodes::ArrayItems>
  #end
  #
  #rule item
  #  sn? expression ((sn? ',' &item) / ('' !item)) <::Dog::Nodes::ArrayItem>
  #end
  
  rule structure
    type:(packaged_identifier sn?)? '{' sn? associations:(first:association rest:(((sn? "," sn?)+ / "\n")  association)* )? (sn? ','* sn?) '}' {
      def transform
        
        structure_type = nil
        structure_value = {}
        
        if !type.empty? then
          structure_type = self.type.packaged_identifier.transform
        end
        
        if !associations.empty? then
          a = associations.first.transform
          structure_value[a.first] = a.last
          
          if self.associations.rest then
            for a in self.associations.rest.elements do
              a = a.association.transform
              structure_value[a.first] = a.last
            end
          end
        end
        
        literal = ::Dog::Nodes::StructureLiteral.new(structure_type, structure_value)
        literal.line = self.line
        
        return literal
      end
    }
    #'{' s? association*  s? '}'
  end

  rule association
    sn? association_key s? '=' s? expression s? {
      def transform
        return [association_key.transform, expression.transform]
      end
    }
    #sn? (identifier / string / number) s? '=' s? expression s? ( "," &association / '' !association)
  end
  
  # TODO - Consider making the the key an expression instead of identifier / string / number. 
  # In particular, does an identifier return an access node look up or not?
  rule association_key
    identifier {
      def transform
        return self.text_value
      end
    }
    / 
    string {
      def transform
        return Shellwords::shellwords(self.text_value).first
      end
    }
    / 
    number {
      def transform
        return self.text_value.to_f
      end
    }
  end
  
  rule string
    (
    '"' ('\"' / !'"' .)* '"'
    /
    '\'' ('\\\'' / !'\'' .)* '\''
    ) {
      def transform
        literal = ::Dog::Nodes::StringLiteral.new Shellwords::shellwords(self.text_value).first
        literal.line = self.line
        
        return literal
      end
    }
  end
  
  rule number
    float / integer
  end
  
  rule integer 
    ('-' s?)? digit+ {
    def transform
      literal = ::Dog::Nodes::NumberLiteral.new self.text_value.to_f
      literal.line = self.line
      
      return literal
    end
    }
  end
  
  rule float
    ('-' s?)? digit+ '.' digit* {
      def transform
        literal = ::Dog::Nodes::NumberLiteral.new self.text_value.to_f
        literal.line = self.line
        
        return literal
      end
    }
  end

  rule bool
    (true / false)
  end

  rule true
    ('TRUE' / 'true') {
      def transform
        node = ::Dog::Nodes::TrueLiteral.new
        node.line = self.line
        return node
      end
    }
  end

  rule false
    ('FALSE' / 'false') {
    def transform
      node = ::Dog::Nodes::FalseLiteral.new
      node.line = self.line
      return node
    end
  }
  end
  
  rule null
    ('NULL' / 'null') {
    def transform
      node = ::Dog::Nodes::NullLiteral.new
      node.line = self.line
      return node
    end
  }
  end
  
  
  
  
  # ===================
  # = Building Blocks =
  # ===================
  
  rule identifier
    lower (lower / digit / '_')*
  end
  
  rule digit
    [0-9]
  end

  rule character
    lower / upper / '_'
  end

  rule lower
    [a-z]
  end

  rule upper
    [A-Z]
  end

  rule t
    terminal
  end

  rule terminal
    (";" / comment / "\n" / end_of_file)
  end

  rule comment
    '#' (!"\n" .)* ("\n" / end_of_file)
  end

  rule sn
    space_newline
  end

  rule space_newline
    (" " / "\t" / "\n" / "\r" / comment)+
  end
  
  rule s
    space
  end

  rule space
    (" " / "\t")+
  end

  rule end_of_file
    !.
  end

end

end
