
Things that are bothering me:

	Call and build use the stack to invoke functions
	Parameter passing for functions
	No access to the package name in the parser
	Nested function names / type names / access paths?
	Bootstraping the Type type







Originaly we liked it when Dog only had 4 commands. It was really elegant and simple to explain:

ASK
NOTIFY
LISTEN
COMPUTE

We then realized that we definitely need functions in the langauge but decided to keep on using COMPUTE for local Dog functions as well as machine functions. In doing so, we were able to keep the language down to the original 4 commands.

However, as we built bigger and bigger applications we realized that we were relying more and more on internal Dog functions. For example, to add a user to a community:

learners = COMPUTE add ON learner, learners

This is really awkward so we decided to add additional commands to make it a bit nicer:

ADD
SAVE
APPEND
...

However this starts to spiral out of control. Furthermore, the semantics of these commands are complicated and very specific. If it does not meet the exact need of a developer we will need to add an additional top-level commands or force developers to use our COMPUTE syntax to call system Dog functions. Both of which are not ideal.

Another middle-of-the-road solution is to explore alternative syntax for invoking Dog functions that is flexible and easy to understand. That way, instead of adding new commands for every new use case we find, we can just add a nicely designed functional API. Futhermore, this functional API will likely be easier for developers to learn since it will be utilizing a standardized invocation syntax and familiar semantics rather than having to learn the intricacies of every new command we dream up.

Additionally, we solve the original problem of avoiding awkward syntax like: "COMPUTE add ON learner, learners" at the paltry expense of not using 'COMPUTE' for both external machine functions and Dog functions.

Thus, the new proposal is to add a new way to invoke Dog functions. The original "4 commands" will remain in the language without virtually any user-facing change with the exception that 'COMPUTE' will ONLY be used to invoke an external machine function rather than also being used to execute Dog functions. (Internally, there will be some additional changes: namely all of the 4 commands will be re-written as standard Dog function calls but that is not user-facing so we can ignore it.)

Here are some proposals for the invocation syntax:

# Simple and straight forward but confusing. What is 0? What is 5?
substring("Hello, World!", 0, 5)

# We can solve this problem with named parameters. However, the , and = may be a bit much.
substring(source = "Hello, World!", from_index = 0, with_length = 5)

# We can also explore ':' instead of parens to call functions. This is very similar to smalltalk:
substring:"Hello, World" from_index:0 with_length:5

# If we want to chain function together, we just add parens for order of operations:
print:(substring:(random_string) from_index:0 with_length:5)

substring << "Hello, World" << 0 << 5







Two special "types"
	Type "type"
	Function "type"
	
	You can invoke these with call and build.
	Byte code verifier
		Checks for duplicate functions
		Checks for types with multiple stuff

	How do I handle the persistence capabilities of Dog when calling a native function from the API?

"Macro System"

	Dog VM
		Symbol table organization:
			{
				name
				value: {
					type: function
					value: {
						name: <@naother_+symbol>
					}
				}
				implementations: [
					{
						catch_table,
						instructions:
						mandatory_arguments:
						optional_arguments:
						type: {human | machine}
					}
				]
			}
			
	
	
	build
	
	Create a small but complete set of "nodes"
		StructureLiteral
		StringLiteral
		NumberLiteral
		TrueLiteral
		FalseLiteral
		NullLiteral
		Assign
		Access
		Operation
		Branch
		Loop
		Break
		Call
		Return
	
	Down the road create instructions:

		Pop
		Push(value=null)
		PushString(value=null)
		PushNumber(value=null)
		PushTrue
		PushFalse
		PushNil
		PushStructure(type=nil)
		Access(path_size)
		Assign(path_size)
		ReadVariable
		WriteVariable
		Perform(operation)
		Jump(offset)
		JumpIfTrue(offset)
		JumpIfFalse(offset)
		Call(function, package, arg_count=0)
		Return
		Throw(name)


		
		# Pseudo instructions
		label(name) # nop
		seek(label, direction)
		
		Each node has a compile method and we call those recursively from the top.
		Each nodes returns an array of the instructions that it (and its descendants)
		compile down to. These are then combined by the parent, and recusively returned
		as you would expect.
		
		Once the instructions for the current function is over, I then scan over it and
		convert / replace any pseudo instructions. Right now, all this would be is seek.
		Seek will be converted to jumps with their jump distances computed at compile time.
		
		Consider adding an exception table (like JVM / YARV). This will handle
		exceptions as well as possibly provide a workaround for converting seeks.
		That is how YARV implements retry / next / break / throw. In which case, I may
		want to remove the "seek" command and instead implement a "throw" command
		instead. See: http://yarvinstructions.heroku.com/notes
		
	Re-write much of the syntax in terms of these nodes instead of creating your own
		There is no longer a While node, just a loop with a branch and break
		There is no longer an unless, just a branch that is re-written to be negated
		Etc.
		
	This it much easier to test, manage, iterate and optimize
	
	Issues:
	
		It may be hard to write the equivalent node structure for a given expression. I need some syntax to make it easier
	
		Can I have reused higher-level rules? For example, create a util expression by reusing a while expression instead of remaking it. I would need to expose a node to do that, right?
	
		How do I implement things like PRINT or LISTEN which need to do stuff. I would have to expose a node to do that, right?
			Pair stuff with functions. The PRINT expression should be a rewrite of COMPUTE print ON "val"
			This means that I need to make function calls VERY efficient
			
			Why would I want to do this?
				It keeps the VM simple and small
				It keeps the language core consistent without adding more
				Separation of UI (syntax) and backend (runtime)
		
		Add additional nodes only if you cannot do things as a function or for performance reasons (either function call overhead or node-rewrite overhead)
		
		General performance with stack and has_path, etc.






Virtual Properties

Macros
	Do I feel okay about macros and side-effects?

Criticisms of Dog:
	It is a new language (security issues, performance problems, lack of stability)
	The syntax is not the easiest or most conducive for building large applications - and do we have the property suitable abstraction capabilities?
	The lack of library support
	It is a special purpose language - however, it that purpose too broad or too constrained? What if I wanted to build something off the trodden path --- can I? Do I have low level enough support to do things like implement a bookmarklet or a TCP handling mechanism?
	Semantics --- are they useful? How hard will the client-side javascript be?

Pending structures
	- Are they able to be shared? How do you pass in a channel to another function for call backs?
	- Investigate the API with Go channels (especially timers)
	- Investigate the API with Python yield


Things left to implement:

	Import

	Communities

	Predicates

	External functions

	Implement unary operator

	Dog error reporting

	Dog unit test cases

	Add support for nested collections and nested functions inside of "ACCESS" - this would be the so called "cascasing" scope modifier.

	Update COMPUTE, ASK, LISTEN, etc to take an expression rather than just an identifier. Note: This does mean augmenting defintions with package information

	using @state instead of track.has_visited?

	Evaluator / Interpretter (related to bite code)

	Decide on anonymous functions vs blocks vs channels

Done:

	Organiation of the bite code and symbol table (filenames)

	System libraries (The ability to implement dog functions in Ruby)

	Scopes when ACCESSing

	Add a "type", "definition" or "symbol" structure to refer to definitions and box it as a value.

	Collections API

	People

	Null Pointer references for symbol look ups. Don't seem to be handled too well. Try to use system.add and it will not work.



Add unit parser tests for:
	import
	config
	
dog compile and dog run
	Extensions are optional..

Dog restart instead of Dog debug

Error codes
	Integration with a discussion page
	Integration with stack overflow
	Integration with a documentation URL

Abreviate file paths to relative paths in error message

Configuration file should be called:
	project.config
	
	Dog init will add in project.config
	
	Also consider including a read only CONFIG command to give access from within Dog
	
Line numbers should be formatted as:
	"In line {number} of {file}" rather than "file:number"

Right now we have static linked libraries (with import). We may want to introduce a capability to dynamically link as well... maybe?

Right now import will always import files relative to the current file. In this way it acts much like require_relative in ruby instead of plain require. We may want a way to add a non-relative import that uses a LOAD_PATH to use shared libraries in a common system location.

Potentially reorgnize the directory structure. Basically, reduce right now there are a lot of dependcies between the main folders.

Multiple VMs per process

Organize the symbol table hierarchically
	- Makes it easier to find stuff by the funciton scopes
	- Maybe something like this will work:
		symbols: {
			"foo": {
				"@path": [1,2,3]
				"bar": {
					"@path": [1,2,3,4]
				}
			}
		}







Add a package-level configuration functionality that also breaks out side effect rules and is linked to the project.config file? Useful for common things like file paths, or flags, etc.? Perhaps not writeable while the project is running, but at the very least standardized for package developers.










Ruby API (similar to the C api for ruby)
	Perhaps an "Init_MODULE_NAME" function that manipulates the AST (or perhaps just manipulates the function map...)

How do you "require" a C module in ruby and what woudl that look like for Dog???
	Do these do what we expect: "require 'hello'" vs "require 'hello.so'" vs "require 'hello.rb'"
	Should we have the similar approach???

functional languages
	Everything in the language is immutable
	
	Objects / Methods exist from a syntax standpoint
	
	Manipulating an object create a new version thus preserving immutability
	
	You can hold references to the same object but it is your "view" of the object
	
		You cannot "synchronize" an object down its timeline...
		
		It may not make a lot of sense for an object to store a value that does not compose it
		
	There is no "canonical" view of an object - just "your" view of the object
	
		You can however, check for identity and equality. Objects can:
		
			equal and identical
		
			equal but not identical
		
			not equal and not identical
		
			identical but not equal (aka different versions of the same thing)
		
	In Dog, we have a problem of wanting the public to see the "up to date" version of a resource --- but there i not way to merge different views.
	
		Perhaps we model the outside world as an actor that does have a "view" and that view is constructed by the event stream
	



