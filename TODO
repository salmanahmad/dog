
Ensure the proper ASTs

Handle TODOs

Check status on http_response

dog compile and dog run
	Extensions are optional..

Error codes
	Integration with a discussion page
	Integration with stack overflow
	Integration with a documentation URL

Abreviate file paths to relative paths in error message

Line numbers should be formatted as:
	"In line {number} of {file}" rather than "file:number"

Right now we have static linked libraries (with import). We may want to introduce a capability to dynamically link as well... maybe?

Right now import will always import files relative to the current file. In this way it acts much like require_relative in ruby instead of plain require. We may want a way to add a non-relative import that uses a LOAD_PATH to use shared libraries in a common system location.

Organize the symbol table hierarchically
	- Makes it easier to find stuff by the funciton scopes
	- Maybe something like this will work:
		symbols: {
			"foo": {
				"@path": [1,2,3]
				"bar": {
					"@path": [1,2,3,4]
				}
			}
		}



Improve the space efficiency of the bite code generation










Parse the bite code

Server architecture

Node object modeling (eval, etc.)

Serialize the stack

Runtime tree traversal... (updating the "program counter")

What do things like "AccessHead" return and place on the stack?

What about non-primative stack placements like people? Do we need a language wide "json" serialization architecture...





ON EACH variable and LISTEN / ASK collections...

	We have two conflicting goals: search and variable scoping
	
	title
	
	ON EACH video DO
		# does 'title' refer to the global variable or the video
	END
	
	vs
	
	LISTEN FOR videos
	
	videos[title == "hello"]
	
	videos[video.title == "hello"]
	
	vs
	
	@each:videos[video.title == "Hello"]
	

Application Configuration
	Options (pick any of these, can choose multiple):
		
		Command arguments
		
		Stand-alone configuration file
			What should the default name be:
			config.json
			project.json
			project.config
			application.json
			specification.json
			
		CONFIG statements (either a block with {} or key = value) automatically generate the app config
		
		Also consider including a read only CONFIG command to give access from within Dog
		
	







Ruby API (similar to the C api for ruby)
	Perhaps an "Init_MODULE_NAME" function that manipulates the AST (or perhaps just manipulates the function map...)

How do you "require" a C module in ruby and what woudl that look like for Dog???
	Do these do what we expect: "require 'hello'" vs "require 'hello.so'" vs "require 'hello.rb'"
	Should we have the similar approach??? 

