
Virtual Properties

Macros
	Do I feel okay about macros and side-effects?

Criticisms of Dog:
	It is a new language (security issues, performance problems, lack of stability)
	The syntax is not the easiest or most conducive for building large applications - and do we have the property suitable abstraction capabilities?
	The lack of library support
	It is a special purpose language - however, it that purpose too broad or too constrained? What if I wanted to build something off the trodden path --- can I? Do I have low level enough support to do things like implement a bookmarklet or a TCP handling mechanism?
	Semantics --- are they useful? How hard will the client-side javascript be?

Pending structures
	- Are they able to be shared? How do you pass in a channel to another function for call backs?
	- Investigate the API with Go channels (especially timers)
	- Investigate the API with Python yield


Things left to implement:

	Import

	Null Pointer references for symbol look ups. Don't seem to be handled too well. Try to use system.add and it will not work.

	People

	Communities

	Predicates

	External functions

	Implement unary operator

	Dog error reporting

	Dog unit test cases

	Add support for nested collections and nested functions inside of "ACCESS" - this would be the so called "cascasing" scope modifier.

	Update COMPUTE, ASK, LISTEN, etc to take an expression rather than just an identifier. Note: This does mean augmenting defintions with package information

	using @state instead of track.has_visited?

	Evaluator / Interpretter (related to bite code)

	Decide on anonymous functions vs blocks vs channels

Done:

	Organiation of the bite code and symbol table (filenames)

	System libraries (The ability to implement dog functions in Ruby)

	Scopes when ACCESSing

	Add a "type", "definition" or "symbol" structure to refer to definitions and box it as a value.

	Collections API



Add unit parser tests for:
	import
	config
	
dog compile and dog run
	Extensions are optional..

Dog restart instead of Dog debug

Error codes
	Integration with a discussion page
	Integration with stack overflow
	Integration with a documentation URL

Abreviate file paths to relative paths in error message

Configuration file should be called:
	project.config
	
	Dog init will add in project.config
	
	Also consider including a read only CONFIG command to give access from within Dog
	
Line numbers should be formatted as:
	"In line {number} of {file}" rather than "file:number"

Right now we have static linked libraries (with import). We may want to introduce a capability to dynamically link as well... maybe?

Right now import will always import files relative to the current file. In this way it acts much like require_relative in ruby instead of plain require. We may want a way to add a non-relative import that uses a LOAD_PATH to use shared libraries in a common system location.

Organize the symbol table hierarchically
	- Makes it easier to find stuff by the funciton scopes
	- Maybe something like this will work:
		symbols: {
			"foo": {
				"@path": [1,2,3]
				"bar": {
					"@path": [1,2,3,4]
				}
			}
		}


















Ruby API (similar to the C api for ruby)
	Perhaps an "Init_MODULE_NAME" function that manipulates the AST (or perhaps just manipulates the function map...)

How do you "require" a C module in ruby and what woudl that look like for Dog???
	Do these do what we expect: "require 'hello'" vs "require 'hello.so'" vs "require 'hello.rb'"
	Should we have the similar approach???

functional languages
	Everything in the language is immutable
	
	Objects / Methods exist from a syntax standpoint
	
	Manipulating an object create a new version thus preserving immutability
	
	You can hold references to the same object but it is your "view" of the object
	
		You cannot "synchronize" an object down its timeline...
		
		It may not make a lot of sense for an object to store a value that does not compose it
		
	There is no "canonical" view of an object - just "your" view of the object
	
		You can however, check for identity and equality. Objects can:
		
			equal and identical
		
			equal but not identical
		
			not equal and not identical
		
			identical but not equal (aka different versions of the same thing)
		
	In Dog, we have a problem of wanting the public to see the "up to date" version of a resource --- but there i not way to merge different views.
	
		Perhaps we model the outside world as an actor that does have a "view" and that view is constructed by the event stream
	



